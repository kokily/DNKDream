[
 {
   "id": "19a73289-358f-47e7-b7fd-a04ff259d3cb",
   "category": "Nextjs",
   "title": "Next.js 13 Server Components",
   "body": "# Cookies\n`쿠키 기능`을 사용하면 [서버 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components)에서 들어오는 HTTP 요청의 쿠키를 읽어올 수 있습니다. 이는 read-only이므로 쿠키 리퀘스트를 `설정` / `삭제`할 수 없습니다.\n> Vercel의 Next.js 팀은 쿠키 기능 외 쿠키 설정 기능을 추가하기 위해 노력중입니다.\n\n## cookies().get(name)\n쿠키 `이름`을 사용하고 이름과 값이 있는 객체를 리턴하는 메소드입니다. 이름이 있는 쿠키를 찾을 수 없으면 *undefined*를 리턴합니다. 여러 쿠키가 일치할 경우 첫번째 일치되는 항목만 리턴합니다.\n\n*app/page.tsx*\n```tsx\nimport { cookies } from 'next/headers';\n\nexport default function Page() {\n  const nextCookies = cookies();\n  const theme = nextCookies.get('theme');\n  \n  return '...';\n};\n```\n\n## cookies().getAll()\n`get`과 유사하지만 `이름`이 일치하는 모든 쿠기의 목록을 리턴하는 메소드입니다. `이름`을 지정하지 않으면 사용 가능한 모든 쿠키를 리턴합니다.\n\n*app/page.tsx*\n```tsx\nimport { cookies } from 'next/headers';\n\nexport default function Page() {\n  const nextCookies = cookies();\n  \n  return nextCookies.getAll().map((cookie) => (\n    <div key={cookie.name}>\n      <p>Name: {cookie.name}</p>\n      <p>Value: {cookie.value}</p>\n    </div>\n  ));\n};\n```\n\n## cookies().has(name)\n쿠키 이름을 득하고 쿠키가 존재하는지(true) 또는 존재하지 않는지(false)에 따라 부울을 리턴하는 메소드입니다.\n\n*app/page.tsx*\n```tsx\nimport { cookies } from 'next/headers';\n\nexport default function Page() {\n  const cookiesList = cookies();\n  const hasCookie = cookiesList.has('theme');\n  \n  return '...';\n};\n```\n\n# Fetch\nNext.js는 고유한 웹 fetch() API를 확장해 서버의 각 요청이 자체 영구 캐싱 의미 체계를 설정할 수 있도록 합니다.\n브라우저에서 `캐시` 옵션은 fetch 요청이 브라우저의 HTTP 캐시와 상호 작용하는 방식을 나타냅니다. 이 확장을 통해 `캐시`는 서버 사이드 fetch 요청이 프레임워크의 영구 HTTP 캐시와 상호 작용하는 방식을 나타냅니다.\n서버 컴포넌트 내 직접 `async`/`await`를 사용해 `fetch`를 호출할 수 있습니다.\n\n*app/page.tsx*\n```tsx\nexport default async function Page() {\n  // 이 요청은 수동 무효화시까지 캐싱됩니다.\n  // 이는 `getStaticProps`와 유사합니다.\n  // `force-cache`는 default이며 생략 가능합니다.\n  const staticData = await fetch(`https://...`, { cache: 'force-cache' });\n  \n  // 이 요청은 모든 요청시 refetch 합니다.\n  // `getServerSideProps`와 비슷합니다.\n  const dynamicData = await fetch(`https://...`, { cache: 'no-store' });\n  \n  // 이 요청은 10초 동안 캐시되어야 합니다.\n  // `revalidate` 옵션이 있는 `getStaticProps`와 유사합니다.\n  const revalidatedData = await fetch(`https://...`, {\n    next: { revalidate: 10 },\n  });\n  \n  return <div>...</div>;\n}\n```\n\n## fetch(url, options)\nNext.js는 Web fetch() API를 확장하므로 사용 가능한 모든 기본옵션을 사용할 수 있습니다.\n또한 Next.js는 클라이언트와 서버 모두에서 polyfills를 가져오므로 [서버 및 클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components) 모두에서 `fetch`를 사용할 수 있습니다.\n\n### options.cache\n요청이 Next.js HTTP 캐시와 상호 작용하는 방식을 구성합니다.\n```js\nfetch(`https://...`, { cache: 'force-cache' | 'no-store' });\n```\n- `force-cache` (default) - Next.js는 HTTP 캐시에서 일치하는 요청을 찾습니다.\n\t- 일치하는 항목이 있고 최신 항목이면 캐시에서 리턴됩니다.\n    - 일치하는 항목이 없거나 오래된 일치 항목이 있는 경우 Next.js는 원격 서버에서 리소스를 가져오고 다운로드한 리소스로 캐시를 업데이트합니다.\n- `no-store` - Next.js는 캐시를 확인하지 않고 요청이 있을 때마다 원격 서버에서 리소스를 가져오며 다운로드한 리소스로 캐시를 업데이트하지 않습니다.\n\n**참고사항**\n- 캐시 옵션을 제공하지 않으면 cookies()와 같은 동적 기능이 사용되지 않는 Next.js는 `force-cache`로 기본 설정됩니다. 이 경우 기본적으로 `no-store`로 설정됩니다.\n- `no-cache` 옵션은 Next.js의 `no-store`와 같은 방식으로 작동합니다.\n\n### options.next.revalidate\n```js\nfetch(`https://...`, { next: { revalidate: false | 0 | number }}});\n```\n리소스의 캐시 수명(초)를 설정합니다.\n- `false` - 리소스를 무기한 캐시합니다. revalidate와 의미상 동일: Infinity. HTTP 캐시는 시간이 지남에 따라 이전 리소스를 제거할 수 있습니다.\n- `0` - 리소스가 캐시되지 않도록 합니다.\n- `number` - (초 단위) 리소스의 캐시 수명이 최대 `n`초여야 함을 지정합니다.\n\n**참고사항**\n- 개별 `fetch` 요청이 각 라우트의 [기본 재검증](https://beta.nextjs.org/docs/api-reference/segment-config#configrevalidate)보다 낮은 `재검증` 횟수를 설정하면 전체 라우트 재검증 간격이 줄어듭니다.\n- 동일한 라우트에서 동일한 URL을 사용하는 두 개의 fetch 요청이 다른 `revalidate` 값을 갖는 경우 더 낮은 값이 사용됩니다.\n- 편의상 `revalidate`가 숫자로 설정된 경우 `0`은 `cache: 'no-store`'를 의미하고 양수 값은 `cache: force-cache`를 의미하므로 캐시 옵션을 설정할 필요가 없습니다.\n- `{ revalidate: 0, cache: 'force-cache' }` 또는 `{ revalidate: 10, cache: 'no-store' })`와 같은 충돌 옵션은 쿠키 헤더에 에러를 발생시킵니다.\n\n# Headers\n`headers` 기능을 사용하면 서버 컴포넌트에서 들어오는 HTTP 요청 헤더를 읽을 수 있습니다.\n\n## headers()\n이 API는 [Web Headers API](https://developer.mozilla.org/en-US/docs/Web/API/Headers)를 확장합니다. read-only이므로 발신 요청 헤더를 `설정` / `삭제`할 수 없습니다.\n\n*app/page.tsx*\n```tsx\nimport { headers } from 'next/headers';\n\nexport default function Page() {\n  const headersList = headers();\n  const referer = headersList.get('referer');\n\n  return <div>Referer: {referer}</div>;\n}\n```\n\n- `Headers.entries()`: 이 객체에 포함된 모든 키 / 값 쌍을 통과할 수 있는 **iterator(반복자)**를 리턴합니다.\n- `Headers.forEach()`: 이 헤더 객체의 각 키 / 값 쌍에 대해 제공된 함수를 한 번 실행합니다.\n- `Headers.get()`: 지정된 이름을 가진 Headers 객체 내의 모든 헤더 값의 문자열 시퀀스를 리턴합니다.\n- `Headers.has()`: Headers 객체에 특정 헤더가 포함되어 있는지 여부를 나타내는 부울을 리턴합니다.\n- `Headers.key()`: 이 객체에 포함된 키 / 값 쌍의 모든 키를 통과할 수 있는 **iterator(반복자)**를 리턴합니다.\n- `Headers.values()`: 이 객체에 포함된 키 / 값 쌍의 모든 값을 검토할 수 있는 **Iterator(반복자)**를 리턴합니다.\n\n## Data Fetching과 함께 사용하기\n`headers()`는 [데이터 fetch를 위해 Suspense](https://beta.nextjs.org/docs/data-fetching/fetching)와 함께 사용할 수 있습니다.\n\n*app/page.tsx*\n```tsx\nimport { headers } from 'next/headers';\n\nasync function getUser() {\n  const headersInstance = headers()\n  const authorization = headersInstance.get('authorization')\n  // Forward the authorization header\n  const res = await fetch('...', {\n     headers: { authorization }\n  })\n  return res.json()\n}\n\nexport default async function UserPage() {\n  const user = await getUser()\n  return <h1>{user.name}</h1>\n}\n```\n\n# Generate Static Params\n`generateStaticParams` 함수는 [동적 라우트 세그먼트](https://beta.nextjs.org/docs/routing/defining-routes#dynamic-segments)와 함께 사용되어 요청 시 주문형이 아닌 프로젝트 빌드 시 정적으로 생성되는 라우트 세그먼트 매개변수 목록을 정의할 수 있습니다.\n\n## generateStaticParams\n`generateStaticParams` 함수는 해당 레이아웃 또는 페이지가 생성되기 전 빌드 타임에 실행됩니다. 재검증(ISR) 중에는 재호출되지 않습니다.\n\n*app/blog/[slug]/page.js*\n```jsx\nexport async function generateStaticParams() {\n  const posts = await getPosts();\n  \n  return posts.map((post) => ({\n    slug: post.slug,\n  }));\n};\n```\n\n`generateStaticParams`에 의해 리턴된 값은 정적 세그먼트 목록을 생성하는데 사용되며, 각 세그먼트는 리턴된 객체의 값을 `params` props로 받습니다.\n\n*app/blog/[slug]/page.js*\n```jsx\nexport default function Page({ params }) {\n  const { slug } = params;\n  \n  return ...\n}\n  \nexport async function generateStaticParams() {\n  const posts = await getPosts();\n  \n  return posts.map((post) => ({\n    slug: post.slug,\n  }));\n};\n```\n\n### Multiple Dynamic Segments in a Route\n현재 레이아웃 또는 페이지 위에는 동적 세그먼트에 대한 세그먼트를 생성할 수 있지만 하위에는 생성할 수 없습니다. 예를 들어 `app/products/[categorySlug]/[productId]` 라우트가 지정된 경우:\n- `app/products/[categorySlug]/[productId]/page.js`는 [*categorySlug*] 및 [*productId*] 모두에 대한 세그먼트를 생성할 수 있습니다.\n- `app/products/[categorySlug]/layout.js`는 [*categorySlug*]에 대한 세그먼트만 생성할 수 있습니다.\n\n여러 동적 세그먼트가 있는 라우트에 대한 세그먼트를 생성하는 방법에는 두 가지가 있습니다.\n\n#### Generate segments from the bottom up\n하위 세그먼트에서 여러 동적 세그먼트를 생성합니다.\n\n*app/products/[categorySlug]/[productId]/page.js*\n```jsx\n// [categorySlug] 및 [productId] 모두에 대한 세그먼트 생성\nexport async function generateStaticParams() {\n  const rows = await query('SELECT category, id FROM products');\n  \n  return rows.map((row) => ({\n    categorySlug: row.category,\n    productId: row.id,\n  }));\n};\n```\n\n#### Generate segments from the top down\n상위 세그먼트를 먼저 생성하고 그 결과를 사용해 하위 세그먼트를 생성합니다.\n\n*app/products/[categorySlug]/layout.js*\n```jsx\n// [categorySlug]에 대한 세그먼트 생성\nexport async function generateStaticParams() {\n  const rows = await query('SELECT category FROM products');\n  \n  return rows.map((row) => ({\n    categorySlug: row.category,\n  }));\n};\n```\n\n자식 세그먼트의 `generateStaticParams` 함수는 부모 `generateStaticParams`가 생성하는 각 세그먼트에 대해 한 번씩 실행됩니다. 자식의 `generateStaticParams` 함수는 자체 세그먼트를 동적으로 생성하는데 사용할 수 있는 부모 세그먼트의 `generateStaticParams` 함수에서 리턴된 개체를 받습니다.\n\n*app/products/[categorySlug]/[productId]/page.js*\n```jsx\n// 상위 세그먼트의 `generateStaticParams` 함수에 의해 전달된 `categorySlug` Props\nexport async function generateStaticParams({ categorySlug }) {\n  const rows = await query(\n    'SELECT id FROM products WHERE categorySlug = ?',\n    categorySlug,\n  );\n\n  return rows.map((row) => ({\n    productId: row.id,\n  }));\n};\n```\n\n`fetch` 요청을 사용해 `generateStaticParams` 함수 내에서 컨텐츠를 가져오면 요청이 [자동으로 중복 제거](https://beta.nextjs.org/docs/data-fetching/fundamentals#automatic-fetch-request-deduping)됩니다. 이는 여러 `generateStaticParams`, `Layout`, `Pages`에서 동일한 인수(`argument`)를 사용하는 fetch 요청이 한 번만 수행됨을 의미합니다.\n\n#### Catch-all and Optional Catch-all Dynamic Segments\n동적 세그먼트가 `[...slug]`와 같은 범용 동적 세그먼트이거나 `[[...slug]]`와 같은 선택적 범용 동적 세그먼트인 경우 생성된 정적 세그먼트의 값은 문자열 배열:\n\n*app/products/[...slug]/page.js*\n```jsx\nexport async function generateStaticParams() {\n  return [\n    { slug: ['electronics', '1'] }, // -> /products/electronics/1,\n    { slug: ['clothing', '2'] },  // -> /products/clothing/2,\n    { slug: ['books', '3'] }  // -> /products/books/3\n    // ...\n  ];\n}\n```",
   "tags": ["nextjs","Server","Component","서버 컴포넌트"],
   "thumbnail": "https://image.dnkdream.com/20221222_0252Th_server-g58f8508f1_640.jpg",
   "createdAt": "2022-12-22 02:52:59.851",
   "updatedAt": "2022-12-22 02:52:59.851"
 },
 {
   "id": "3215644a-f392-4c1f-b0bc-057427801ae1",
   "category": "잡담",
   "title": "비가 많이 옵니다",
   "body": "# 장마....\n비가 어마무시하게 내린다.\n그저께부터 오기 시작하더니 그치질 않네.. ㅜㅜ\n새벽에 부모님 일을 돕다보니 비를 그대로 다 맞아야 하는데 시원해서 좋긴 하지만 빨래가 너무 밀린다...\n\n창 밖에 비가 오는 걸 보면서 코딩을 하다보니 갬성(?)이 자극되어서 이런 저런 글을 찾아보다가 김다슬 작가님의 김다슬 에세이의 글귀를 몇 가지 보게 되었다.\n별 말 아닌 것 같은 글귀가 너무 와닿는 글들이 많았다.\n그 중에서 가장 갬성을 자극하는 글을 한 번 적어본다.\n\n> 김다슬 작가님 \"김다슬 에세이\" 중...\n\n# 평생동안 곁에 남을 진짜 친구는\n\n## 1. 그냥 연락한다.\n아무런 용건이 없이 통화해도 어색함이 없다.\n필요할 때만 찾는 사람과는 근본적으로 다르다.\n\n## 2. 전화 한 통에 기분이 풀린다.\n어이없고 짜증나는 일도 친구와 통화 한 번이면 짜증, 불안, 화가 가라앉고 답답했던 속이 한결 나아진다.\n\n## 3. 시시한 일상을 공유한다.\n이런 사소한 것 까지 얘기하나 싶을 정도로 시시한 일을 함께 공유하는 것이 즐겁다.\n\n## 4. 쓸데없는 얘기로 웃는다.\n남이 보기엔 웃기지도 않고 이해할 수 없는 얘기도 둘 만의 코드가 잘 맞아서 빵빵 터지며 웃게 된다.\n\n## 5. 나를 위해 준다.\n모든 행동에 날 위하는 마음이 묻어 있다. 쓴 소리도 내 생각해서 따끔하게 하고, 힘들 때는 그저 들어주고, 슬프고 우울할 땐 곁에서 어떻게든 위로해준다.\n\n인간관계는 대부분 필요와 이해로 얽혀 있다.\n계산적인 관계들 사이에서 아이처럼 목적없이 순수한 관계인 친구가 있다면 삶의 보물같은 사람이다.\n그 친구와의 우정을 평생 지킨다면 그것만으로 참 근사한 인생이 된다.\n> 지금 떠오른 그 친구 말이다.\n\n# 기분을 관리하면 인생이 관리된다\n이 글귀가 들어있는 [책의 이름](http://www.yes24.com/Product/Goods/108624716)\n이다.\n\n비 오는 날 괜한 갬성(?) 폭발로 보게 된 글귀가 너무 가슴을 울린다.\n\n![](https://image.dnkdream.com/220630_174710_405345e0d45fd7413420da204)",
   "tags": ["비","갬성","생각나는 친구"],
   "thumbnail": "https://image.dnkdream.com/220630_173653_405345e0d45fd7413420da203",
   "createdAt": "2022-06-29 23:47:02.006",
   "updatedAt": "2022-11-13 06:34:47.367"
 },
 {
   "id": "45f214bd-c0c4-43a1-a26a-c829b7fe8197",
   "category": "Nextjs",
   "title": "Next.js 13 API Reference - Script",
   "body": "이 API Reference는 Script 컴포넌트에 사용할 수 있는 [Props](https://beta.nextjs.org/docs/api-reference/components/script#props) 사용 방법을 이해하는데 도움이 됩니다. 기능 및 사용법에 대해서는 스크립트 [Optimizing Scripts](https://beta.nextjs.org/docs/optimizing/scripts) 페이지를 참조하세요.\n```tsx\nimport Script from 'next/script';\n\nexport default function Dashboard() {\n  return (\n    <>\n      <Script src=\"https://example.com/script.js\" />\n    </>\n  );\n};\n```\n\n# Props\n다음 표는 Scrip 컴포넌트에 사용할 수 있는 Props에 대한 요약입니다.\n| Prop | Example | Type | Required |\n| --- | --- | --- | --- |\n| [src] | `src=\"https://example.com/script\"` | String | Required unless inline script is used |\n| [strategy] | `strategy=\"lazyOnload\"` | String | - |\n| [onLoad] | `onLoad={onLoadFunc}` | Function | - |\n| [onReady] | `onRead={onReadFunc}` | Function | - |\n| [onError] | `onError={onErrorFunc}` | Function | - |\n\n# 필수 Props\n`<Script />` 컴포넌트에는 다음 속성이 필수적으로 필요합니다.\n\n## src `필수적`\n외부 스크립트의 URL을 지정하는 경로 문자열입니다.\n이는 절대 외부 URL 또는 내부 경로일 수 있습니다.\n인라인 스크립트를 사용하지 않는 한 `src` 속성이 필요합니다.\n\n# 선택적 Props\n`<Script />` 컴포넌트는 필수 속성 외 여러 추가 속성을 허용합니다.\n\n## strategy `선택적`\n스크립트의 로딩 전략, 사용할 수 있는 아래 네 가지 전략이 있습니다.\n- `beforeInteractive`: Next.js 코드와 페이지 Hydration이 발생하기 전 로드\n- `afterInteractive`: (기본값) 초기 로드, 페이지에 약간의 Hydration이 발생한 후 로드\n- `lazyOnload`: 브라우저 유휴 시간 동안 로드\n- `worker`: (실험적) Web worker 내 로드\n\n### beforeInteractive (strategy)\n`beforeInteractive` 전략으로 로드되는 스크립트는 서버 초기 HTML에 삽입되고 Next.js 모듈 이전 다운로드되며 페이지 내 Hydration 발생 전 배치된 순서대로 실행됩니다.\n이 전략으로 표시된 스크립트는 내 코드보다 먼저 pre-load 되고 가져오지만 실행으로 인해 페이지 Hydration이 발생하는 것을 차단하지는 않습니다.\n`beforeInteractive` 스크립트는 루트 레이아웃(`app/layout.tsx`) 내 배치해야 하며 전체 사이트에 필요한 스크립트를 로드하도록 설계되었습니다.\n(즉, 애플리케이션 페이지가 서버 측 로드 시 스크립트가 로드됨)\n**이 전략은 페이지 내 일부 요소가 대화형(Interactive)이 되기 전 가져와야 하는 중요한 스크립트에만 사용해야 합니다.**\n\n*app/layout.tsx*\n```tsx\nimport Script from 'next/script';\n\nexport default function RootLayout({ children }: { children: ReactNode; }) {\n  return (\n    <html lang=\"en\">\n      <body>{children}</body>\n      <Script\n        src=\"https://example.com/script.js\"\n        strategy=\"beforeInteractive\"\n      />\n    </html>\n  );\n};\n```\n> `beforeInteractive`가 포함된 스크립트는 컴포넌트 위치에 상관없이 항상 HTML 문서 `head` 내부에 삽입됩니다.\n\n`beforeInteractive`로 가능한 빨리 로드되어야 하는 스크립트는 예는 아래와 같습니다.\n- Bot Detectors\n- Cookie consent managers\n\n### afterInteractive (strategy)\n`afterInteractive` 전략을 사용하는 스크립트는 HTML 클라이언트 사이드에 삽입되며 페이지 내 일부(또는 전체) Hydration 이후 로드됩니다. 이는 `Script` 컴포넌트의 **기본 전략**이며 내 Next.js 코드 이전이 아닌 가능한 빨리 로드해야 하는 모든 스크립트에 사용합니다.\n`afterInteractive` 스크립트는 모든 페이지 또는 레이아웃 내부에 배치할 수 있으며 해당 페이지(또는 페이지 그룹)가 브라우저에서 열릴 때만 로드 및 실행됩니다.\n\n*app/page.tsx*\n```tsx\nimport Script from 'next/script';\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        strategy=\"afterInteractive\"\n      />\n    </>\n  );\n};\n```\n\n`afterInteractive`에 적합한 스크립트의 예제는 아래와 같습니다.\n- Tag managers\n- Analytics\n\n### lazyOnload (strategy)\n`lazyOnload` 전략을 사용하는 스크립트는 브라우저 유휴 시간 동안 HTML 클라이언트 사이드에 삽입되며 페이지 모든 리소스를 가져온 후 로드됩니다. 이 전략은 초기 로드할 필요가 없는 백그라운드 또는 낮은 우선순위 스크립트에 사용되어야 합니다.\n`lazyOnload` 스크립트는 모든 페이지 또는 레이아웃 내부에 배치할 수 있으며 해당 페이지(또는 페이지 그룹)가 브라우저에서 열릴 떄만 로드 및 실행됩니다.\n\n*app/page.tsx*\n```tsx\nimport Script from 'next/script';\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        strategy=\"lazyOnload\"\n      />\n    </>\n  );\n};\n```\n\n즉시 로드할 필요없는 `lazyOnload`로 가져올 수 있는 스크립트는 아래와 같습니다.\n- Chat support plugins\n- Social media widgets\n\n### worker (strategy)\n> 주의: `worker` 전략은 아직 안정적이지 않으며 `app` 디렉토리에서 작동하지 않습니다. 주의해 사용해 주세요.\n\n`worker` 전략을 사용하는 스크립트는 기본 스레드를 해제하고 중요한 내 리소스만 처리되도록 하기 위해 web worker에게 off-loaded 됩니다. 이 전략은 모든 스크립트에 사용할 수 있지만 모든 타사 스크립트를 지원한다고 보장할 수 없는 고급 사용 사례입니다.\n\n`worker` 전략을 사용하려면 *nextScriptWorkers* 플래그를 *next.config.js*에서 활성화해야 합니다.\n```js\nmodule.exports = {\n  experimental: {\n    nextScriptWorkers: true,\n  },\n};\n```\n\n`worker` 스크립트는 현재 *pages/* 디렉토리에서만 사용할 수 있습니다.\n\n*pages/home.tsx*\n```tsx\nimport Script from 'next/script';\n\nexport default function Home() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        strategy=\"worker\"\n      />\n    </>\n  );\n};\n```\n\n## onLoad `선택적`\n> 주의: `onLoad`는 아직 서버 컴포넌트에서 작동하지 않으며 클라이언트 컴포넌트에서만 사용할 수 있습니다. 또한 `onLoad`는 `beforeInteractive`와 함께 사용할 수 없습니다. 대신 `onReady`를 사용하는 것이 좋습니다.\n\n일부 타사 스크립트는 컨텐츠를 인스턴스화하거나 함수를 호출하기 위해 스크립트 로드가 완료된 후 사용자가 자바스크립트 코드를 한 번 실행하도록 요구합니다. `afterInteractive` 또는 `lazyOnload`를 전략으로 사용해 스크립트를 로드하는 경우 `onLoad` 속성을 사용해 로드 후 코드를 실행할 수 있습니다.\n\n아래는 라이브러리가 로드된 후 `loadash` 메소드를 실행하는 예입니다.\n\n*app/page.tsx*\n```tsx\n'use client'\n\nimport Script from 'next/script';\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.20/lodash.min.js\"\n        onLoad={() => {\n          console.log(_.sample([1, 2, 3, 4]))\n        }}\n      />\n    </>\n  );\n};\n```\n\n## onReady `선택적` \n> 주의: `onReady`는 아직 서버 컴포넌트에서 작동하지 않으며 클라이언트 컴포넌트에서만 사용할 수 있습니다.\n\n일부 타사 스크립트는 스크립트 로드가 완료된 후 컴포넌트가 마운트 될 때마다(예: 경로 탐색 후) 사용자가 자바스크립트 코드를 실행하도록 요구합니다. `onReady` 속성을 사용해 스크립트의 로드 이벤트가 처음 로드된 후 모든 후속 컴포넌트가 다시 마운트 된 후 코드를 실행할 수 있습니다.\n\n아래는 컴포넌트가 마운트 될 때마다 Google Maps JS 삽입을 다시 인스턴스화 하는 방법 예시입니다.\n\n*app/page.tsx*\n```tsx\n'use client'\n\nimport { useRef } from 'react';\nimport Script from 'next/script';\n\nexport default function Page() {\n  const mapRef = useRef();\n\n  return (\n    <>\n      <div ref={mapRef}></div>\n      <Script\n        id=\"google-maps\"\n        src=\"https://maps.googleapis.com/maps/api/js\"\n        onReady={() => {\n          new google.maps.Map(mapRef.current, {\n            center: { lat: -34.397, lng: 150.644 },\n            zoom: 8,\n          })\n        }}\n      />\n    </>\n  );\n};\n```\n\n## onError `선택적`\n> 주의: `onError`는 아직 서버 컴포넌트에서 작동하지 않으며 클라이언트 컴포넌트에서만 사용할 수 있습니다. `onError`는 `beforeInteractive` 로딩 전략과 함께 사용할 수 없습니다.\n\n가끔 스크립트가 로드되지 않을 때 파악하는 것이 도움이 됩니다. 이러한 에러는 `onError` 속성으로 처리할 수 있습니다.\n\n*app/page.tsx*\n```tsx\n'use client'\n\nimport Script from 'next/script';\n\nexport default function Page() {\n  return (\n    <>\n      <Script\n        src=\"https://example.com/script.js\"\n        onLoad={(e) => {\n          console.error('Script failed to load', e)\n        }}\n      />\n    </>\n  );\n};\n```",
   "tags": ["nextjs","API","Reference","Script"],
   "thumbnail": "https://image.dnkdream.com/20221221_2040We_artificial-intelligence-g8ff61394e_640.jpg",
   "createdAt": "2022-12-21 21:21:50.769",
   "updatedAt": "2022-12-21 21:21:50.769"
 },
 {
   "id": "4a75b1c9-d9ad-42bb-8f31-fa5a72628a5a",
   "category": "Remix",
   "title": "Jokes App with Remix",
   "body": "이전 포스트에서 적었듯이 이번엔 리믹스를 이용해서 랜덤 한줄 농담을 뿜어주고 등록하는 웹을 만들어볼 예정입니다.이는 리믹스 공식 홈페이지 튜토리얼에 있는 내용이며, 이를 통해서 리믹스 내에서 제공하는 API의 개요를 확인할 수 있습니다.\n\n이 튜토리얼은 타입스크립트를 사용합니다.타입스크립트를 사용할 때 리믹스는 더욱 좋아집니다. 특히나 SQLite 데이터베이스에서 데이터 모델에 엑세스를 하는 용도로 [Prisma](https://www.prisma.io/)를 사용할 예정이기 때문에 타입스크립트가 더욱 더 좋습니다.\n\n이번 튜토리얼은 아래와 같은 순서로 작성됩니다.\n\n🐷 리믹스 프로젝트 생성\n🐷 리믹스 프로젝트 기존 파일\n🐷 라우트 (중첩 경로 포함)\n🐷 스타일링\n🐷 데이터베이스 상호 작용\n🐷 뮤테이션 및 검증 (Validation)\n🐷 인증 (Authentication)\n🐷 에러 핸들링\n🐷 메타 태그가 있는 SEO\n🐷 리소스 경로\n🐷 자바스크립트\n🐷 Optimistic UI\n🐷 배포 (Deployment)\n\n기존에는 리믹스 공식 홈페이지 내 `Tutorial` 중 하나인 *App Tutorial(long)* 을 작성하려 했으나 공식 Docs를 먼저 번역해보려고 합니다.",
   "tags": ["Remix","React","랜덤 농담"],
   "thumbnail": "https://image.dnkdream.com/220923_143406_d4bfb027666bdd7f358395f01",
   "createdAt": "2022-09-22 20:35:54.771",
   "updatedAt": "2022-12-23 21:07:26.492"
 },
 {
   "id": "575a983d-4832-4a88-ae09-ac52559a4c7e",
   "category": "잡담",
   "title": "아 일하기 싫다!!",
   "body": "# 나는 개발자가 아니다\n어린 시절 게임 개발을 하고 싶어 헌책방에서 C언어 책들을 사서 읽곤 했었는데, 당시 부모님께서 컴퓨터를 구매해 주지 않으셔서 공부를 제 때 못해 장래 희망이었던 프로그래머를 접게 되었다.\n이후 정처없이 살다가 군 입대 후 부사관으로 지원하여 14년의 군생활을 마치고 전역하여 현재 다니는 직장(회사)에 오게 되었다.\n\n## 적성?? 흥미??\n적성과 흥미는 엄연히 다른 것이지만 현역 시절 군수 업무를 맡아 했어서 그런지 현재 이 회사에서 하는 업무(군수 관련 업무)는 정말 편하고 익숙하여 좋기는 하지만 너무너무.... 재미가 없다!!!!\n좋아하는 분야에서 직업을 갖는다는 건 꿈만 같은 일이겠지만 사실 그런 분들을 볼 때마다 참 부럽기도 하고 난 왜 저리 열정적이지 못할까 많이 자책을 한다. 물론 지금 이순간도...\n지금 이런 블로그를 스스로 개발해서 내가 좋아하던 프로그래밍 공부를 다시금 할 수 있는 것만 해도 참 행복한 일이지만 업무, 개인적인 일, 가족 관계, 친구 관계를 유지하며 중간중간 해 나간다는 것이 생각만큼 쉽지 않지만 사실 누군들 안 그런가??\n\n# 징징(핑계) vs 정당한 불만\n\n사실 나는 성실하다(ㅋㅋㅋㅋ....)\n내 입으로 말해 뭐하긴 하지만 일에 집중할 때에는 정말 앞 뒤 안 재고 일만 할 정도로 빠져서 한다.\n이게 엄청난 장점이자 단점이 되는데, 남들 다 갖는 취미 생활 하나 제대로 가지지 못하고 사람들과의 교류(동아리 같은)도 자주 하지 못하는... (알콜 매니아인데!!)\n\n> 난 참 재미없는 인생을 살고 있다.\n\n# 기회인가? 아니면 단순 취미인가\n그렇게 무기력하게 지내오던 중 갑자기 나의 흥미를 잡아 끄는 일이 생겼다. 바로 웹 코딩이었다.\n뜬금 웹 코딩을 하게 되었던 계기는 전역 후 8개월 간 휴식을 했었는데 그 중 했던 와우 라는 게임이었다.\n![](https://image.dnkdream.com/220615_141735_ba531520754442c329d386a0c)\n\n이 와우라는 게임에서 한 길드에 들어가게 되었는데, 너무나 가족같은 분위기, 친밀감에 자주 정모도 하고 번개도 하며 나이가 웬만큼 먹었는데 게임 때문에 누구를 만나 친해진다는 게 신기하기도 하여 너무 재밌게 생활했었다.\n그러던 중 우리 길드를 홍보해 보고 싶은 생각이 들어 열심히 구글링하여 길드 홈페이지를 만들고, 다시 그 홈페이지를 직접 운영해보고 싶어 라즈베리파이로 웹 서버를 구축하여 이것저것 삽질(?) 을 해본 것이 개발의 시작이었다.\n\n# 개발 언어의 선택(선택장애 OTL)\n웹 코딩을 하려고 달려들어보니 사용할 수 있는 언어, 프레임워크가 너무 무궁무진하더라.\n친한 동생(사실 군 간부 시절 데리고 있던 병사ㅋ)이 백앤드 개발자인데\n\n> 형 리액트 함 해봐용\n\n이라는 말에 자바스크립트도 공부하지 않은 상태로 뛰어들었었다.\n결과는 ㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎㅎ ㅜㅜ\n한글로 된 자료도 별로 없던 시절, 구글링을 열심히 하고 Velopert(김민준)님, Nomad coder님 등의 자료들을 죽어라 공부해가며 이것 저것 만들어본 결과 지금은 간단한 쇼핑몰 정도는 구축할 정도가 되었다. 하하핫!\n\n# 행사전표시스템(KoaJS, NextJS)\n현재 내가 다니고 있는 회사는 연회(파티), 웨딩, 컨벤션 등을 주로 하는 곳으로 각 홀 담당자들이 대금 결제를 위한 빌지(영수증)를 손으로 적어서 인포메이션에 내려가 결제를 진행하는 것을 보았다.\n\n> 아니 요즘같은 IT 시대에 이 무슨... ㅡ,.ㅡ;\n\n그러던 중 우리 부장님이 \"웹 만들 줄 아시는 것 같던데, 전표 폰으로 작성할 수 있게 해주고 인포에서 출력할 수 있게 해주면 좋지 않을까요? ^^\" 라고 하여 뜬금 개발하기 시작한 행사전표시스템\n지금은 꽤나 버전이 올라가 5.1버전으로 운영중이고, 처음엔 Express 서버에 ejs 템플릿으로 만들었다가, Koa 서버에 React 로 리팩토링, 또다시 graphql로 리팩토링, 이후 현재는 @reduxjs/toolkit 이 나와 운영중에 있다.\n다시 버전업을 계획하고 있으며 다음 버전은 react-query를 사용할 예정이다. (현재 이 블로그가 react-query ㅋㅋ)\n\n# React-Native\n리액트를 보다보니 욕심이 생겨 앱 제작도 해보고 싶었다. 하지만 요즘 대세라는 Flutter 는 여태껏 내가 공부해온 언어와 스타일이 너무 달라서 달려들지를 못했고, 같은 페이스 북에서 제작한 React-Native를 이용하여 앱을 두어번 만들어봤고, 실제 출시도 2번 했다. ㅋㅋㅋ\n창피해서 어디 보여줄 수준은 안되지만 이것 또한 좋은 경험이 되리라!\n![](https://image.dnkdream.com/220615_142850_ba531520754442c329d386a0d)\n\n# 결론(?)\n결론은 없다.\n하하하하하하하핫...\n개발자도 아니고 독학(구글링)으로 공부를 하다보니 막힐 때마다 참 답답하고 영어도 잘 못하니 매번 머리를 쥐어짜가며 고민하고 이런 방법 저런 방법 해보는데 이러다 성공하면 너무너무 기분이 좋다!!!! >ㅁ<\n이 맛에 하는 건가 ㅋㅋ",
   "tags": ["잡담","푸념","소심"],
   "thumbnail": "https://image.dnkdream.com/220615_141020_ba531520754442c329d386a0b",
   "createdAt": "2022-06-14 20:28:58.179",
   "updatedAt": "2022-11-13 06:34:14.807"
 },
 {
   "id": "686791e9-5bff-4046-a648-81b41c156d06",
   "category": "Nextjs",
   "title": "Next.js 13 Client Component Hooks",
   "body": "# useRouter\n`useRouter` 훅을 사용하면 [클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components) 내에서 프로그래밍 방식으로 라우트를 변경할 수 있습니다.\n> `useRouter` 사용에 대한 특정 요구사항이 없는 한 탐색 시 [\\<Link>](https://beta.nextjs.org/docs/routing/linking-and-navigating#link-component) 컴포넌트를 기본으로 사용하세요\n\n*app/page.tsx*\n```tsx\n'use client';\n// `use client`는 이 페이지는 클라이언트 컴포넌트라는 표식입니다.\n// https://beta.nextjs.org/docs/rendering/server-and-client-components\n\nimport { useRouter } from 'next/navigation';\n\nexport default function Page() {\n  const router = useRouter();\n  \n  return (\n    <button type=\"button\" onClick={() => router.push('/dashboard')}>\n      Dashboard\n    </button>\n  );\n};\n```\n\n## useRouter()\n- `router.push(href: string)`: 제공된 라우트에 대한 클라이언트 사이드 탐색을 수행합니다. [브라우저의 history stack](https://developer.mozilla.org/en-US/docs/Web/API/History_API)에 새 항목을 추가합니다.\n- `router.replace(href: string)`: [브라우저의 history stack](https://developer.mozilla.org/en-US/docs/Web/API/History_API)에 새 항목을 추가하지 않고 제공된 라우트에 대한 클라이언트 사이드 탐색을 수행합니다.\n- `router.refresh()`: 현재 라우트를 새로 고침하고 서버에서 새 데이터를 fetch합니다. 예를 들어 스크롤 위치 또는 form과 같은 state를 재설정하지 않습니다.\n- `router.prefetch(href: string)`: 더 빠른 클라이언트 사이드 전환을 위해 제공된 라우트를 [미리 읽어(prefetch)](https://beta.nextjs.org/docs/routing/linking-and-navigating#prefetching)옵니다.\n- `router.back()`: [소프트 탐색](https://beta.nextjs.org/docs/routing/linking-and-navigating#soft-navigation)을 사용해 브라우저의 history stack에서 이전 라우트로 다시 이동합니다.\n- `router.forward()`: [소프트 탐색](https://beta.nextjs.org/docs/routing/linking-and-navigating#soft-navigation)을 사용해 브라우저의 history stack에서 다음 페이지로 이동합니다.\n\n### 알아두면 좋은 점\n- `push()` 및 `replace()` 메소드는 새 라우트가 미리 가져온 경우 [소프트 탐색](https://beta.nextjs.org/docs/routing/linking-and-navigating#soft-navigation)을 수행하며 [동적 세그먼트](https://beta.nextjs.org/docs/routing/defining-routes#dynamic-segments)를 포함하지 않거나 현재 라우트와 동일한 동적 매개변수를 가집니다.\n- `next/link`는 라우트가 뷰 포트에 표시되면 자동으로 prefetch합니다.\n\n> `pages` 디렉토리에서 마이그레이팅\n> - 새 `useRouter` 훅은 `next/router`가 아닌 `next/navigation`에서 가져와야 합니다.\n> - `pathname` 문자열이 제거되었으며 [usePathname()](https://beta.nextjs.org/docs/api-reference/use-pathname)으로 대체되었습니다.\n> - `query` 객체가 제거되었으며 [useSearchParams()](https://beta.nextjs.org/docs/api-reference/use-search-params)로 대체되었습니다.\n> - `router.events`는 현재 지원되지 않습니다.\n>\n> 전체 [마이그레이션 가이드](https://beta.nextjs.org/docs/upgrade-guide#migrating-routing-hooks)를 확인하세요.\n\n# useSearchParams\n`useSearchParams` 훅을 사용하면 [클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components)에서 URL 검색 매개변수를 읽을 수 있습니다. [서버 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components)에서 [searchParams](https://beta.nextjs.org/docs/api-reference/use-search-params#searchparams-in-server-components)을 사용하세요.\n\n`useSearchParams` 훅은 `URLSearchParams` 인터페이스의 read-only 버전을 리턴합니다.\n\n*app/dashboard/ProjectList.tsx*\n```tsx\n'use client';\n\nimport { useSearchParams } from 'next/navigation';\n\nexport default function Page() {\n  const searchParams = useSearchParams();\n  \n  // '/dashboard?page=2&order=asc'\n  const page = searchParams.get('page');\n  const order = searchParams.get('order');\n  \n  return (\n    <div>\n      <p>Page: {page}</p>\n      <p>Order: {order}</p>\n    </div>\n  );\n};\n```\n\n## Pages의 `searchParams`\n[Pages](https://beta.nextjs.org/docs/api-reference/file-conventions/page)는 `searchParams` props를 통해 URL 검색 매개변수에 액세스 할 수 있습니다.\n\n*app/dashboard/page.tsx*\n```tsx\nexport default function Page({ params, searchParams }: {\n  searchParams?: { [key: string]: string | string[] | undefined };\n}) {\n  // '/dashboard?page=2&order=asc'\n  return (\n    <>\n      <p>Page: {searchParams.page}</p>\n      <p>Order: {searchParams.order}</p>\n    </>\n  );\n};\n```\n\n### 알아두면 좋은 점\n[정적 렌더링](https://beta.nextjs.org/docs/rendering/fundamentals#static-rendering) 중에 `useSearchParams` 훅을 사용하는 모든 컴포넌트는 사전 렌더링을 건너뛰고 대신 런타임에 클라이언트에서 렌더링됩니다.\n\n# useSelectedLayoutSegment\n`useSelectedLayoutSegment`는 호출된 레이아웃보다 **한 수준 아래**에서 액티브 라우트 세그먼트를 읽을 수 있도록 해주는 **클라이언트 컴포넌트 훅**입니다.\n액티브 자식 세그먼트에 따라 스타일을 변경하는 부모 레이아웃 내부의 탭과 같은 탐색 UI에 유용합니다.\n\n*app/ExampleClientComponent.tsx*\n```tsx\n'use client';\n\nimport { useSelectedLayoutSegment } from 'next/navigation';\n\nexport default function ExampleClientComponent() {\n  const segment = useSelectedLayoutSegment();\n\n  return <>Active segment: {segment}</>;\n}\n```\n\n### 알아두면 좋은 점\n- `useSelectedLayoutSegment`는 [클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components#client-components) 훅이고 레이아웃은 기본적으로 [서버 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components#server-components)이므로 `useSelectedLayoutSegment`는 일반적으로 레이아웃으로 가져온 클라이언트 컴포넌트를 통해 호출됩니다.\n- `useSelectedLayoutSegment`는 한 수준 아래의 세그먼트만 리턴합니다. 모든 액티브 세그먼트를 리턴하려면 [useSelectedLayoutSegments](https://beta.nextjs.org/docs/api-reference/use-selected-layout-segments)를 참조하세요.\n\n## API Reference\n```js\nconst segment = useSelectedLayoutSegment();\n```\n\n### Parameters\n`useSelectedLayoutSegment`는 매개변수를 사용하지 않습니다.\n\n### Returns\n`useSelectedLayoutSegment`는 액티브 세그먼트의 문자열을 리턴하거나 존재하지 않을 시 `null`을 리턴합니다.\n아래는 레이아웃 및 URL이 있는 경우 리턴되는 세그먼트의 예제입니다.\n| Layout | Visited URL | Returned Segment |\n| --- | --- | --- |\n| `app/layout.js` | `/` | **null** |\n| `app/layout.js` | `/dashboard` | **dashboard** |\n| `app/dashboard/layout.js` | `/dashboard` | **null** |\n| `app/dashboard/layout.js` | `/dashboard/settings` | **'settings'** |\n| `app/dashboard/layout.js` | `/dashboard/analytics` | **'analytics'** |\n| `app/dashboard/layout.js` | `/dashboard/analytics/monthly` | **'analytics'** |\n\n## 예 제\n`useSelectedLayoutSegment`를 사용해 액티브 세그먼트에 따라 스타일을 변경하는 액티브 링크 컴포넌트를 만들 수 있습니다. 예를 들어 블로그 내 사이드바에 있는 추천 게시물 목록은 다음과 같습니다.\n\n*app/blog/BlogNavLink.tsx*\n```tsx\n'use client';\n\nimport Link from 'next/link';\nimport { useSelectedLayoutSegment } from 'next/navigation';\n\n// 이 클라이언트 컴포넌트는 블로그 레이아웃으로 사용합니다\nexport default function BlogNavLink({\n  slug,\n  children,\n}: {\n  slug: string,\n  children: React.ReactNode,\n}) {\n  // `/blog/hello-world`로 이동 시 선택한 레이아웃 세그먼트에 대해\n  // 'hello-world'가 리턴됩니다.\n  const segment = useSelectedLayoutSegment();\n  const isActive = slug === segment;\n\n  return (\n    <Link\n      href={`/blog/${slug}`}\n      // 링크 액티브 여부에 따라 스타일 변경\n      style={{ fontWeight: isActive ? 'bold' : 'normal' }}\n    >\n      {children}\n    </Link>\n  );\n}\n```\n\n*app/blog/layout.tsx*\n```tsx\n// 클라이언트 컴포넌트를 상위 레이아웃(서버 컴포넌트)로 가져오기\nimport type { ReactNode } from 'react';\nimport { BlogNavLink } from './BlogNavLink';\nimport getFeaturedPosts from './getFeaturedPosts';\n\nexport default async function Layout({\n  children,\n}: {\n  children: ReactNode;\n}) {\n  const featuredPosts = await getFeaturedPosts();\n  return (\n    <div>\n      {featuredPosts.map((post) => (\n        <div key={post.id}>\n          <BlogNavLink slug={post.slug}>{post.title}</BlogNavLink>\n        </div>\n      ))}\n      <div>{children}</div>\n    </div>\n  );\n}\n```\n\n# useSelectedLayoutSegments\n`useSelectedLayoutSegments`는 호출된 레이아웃 하위 액티브 라우트 세그먼트를 읽을 수 있는 **클라이언트 컴포넌트 훅**입니다.\n\n이동 경로와 같은 액티브 하위 세그먼트에 대한 지식이 필요한 상위 레이아웃에서 UI를 생성하는데 유용합니다.\n\n*app/ExampleClientComponent.tsx*\n```tsx\n'use client';\n\nimport { useSelectedLayoutSegments } from 'next/navigation';\n\nexport default function ExampleClientComponent() {\n  const segments = useSelectedLayoutSegments();\n\n  return (\n    <ul>\n      {segments.map((segment, index) => (\n        <li key={index}>{segment}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n### 알아두면 좋은 점\n- `useSelectedLayoutSegments`는 [클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components#client-components) 훅이고 레이아웃은 기본적으로 [서버 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components#server-components)이므로 `useSelectedLayoutSegments`는 일반적으로 레이아웃으로 가져온 클라이언트 컴포넌트를 통해 호출됩니다.\n- 리턴된 세그먼트에는 UI에 포함하지 않으려는 [라우트 그룹](https://beta.nextjs.org/docs/routing/defining-routes#route-groups)이 포함됩니다. `filter()` 배열 메소드를 사용해 대괄화로 시작하는 항목을 제거할 수 있습니다.\n\n## API Reference\n```js\nconst segments = useSelectedLayoutSegments();\n```\n\n### Parameters\n`useSelectedLayoutSegments`는 매개변수를 사용하지 않습니다.\n\n### Returns\n`useSelectedLayoutSegments`는 훅이 호출된 레이아웃에서 한 수준 하위에 있는 액티브 세그먼트를 포함하는 문자열 배열을 리턴합니다. 또는 존재하지 않을 경우 빈 배열입니다.\n\n아래는 레이아웃 및 URL이 있는 경우 리턴되는 세그먼트의 예제입니다.\n| Layout | Visited URL | Returned Segments |\n| --- | --- | --- |\n| `app/layout.js` | `/` | **[]** |\n| `app/layout.js` | `/dashboard` | **['dashboard']** |\n| `app/layout.js` | `/dashboard/settings` | **['dashboard','settings']** |\n| `app/dashboard/layout.js` | `/dashboard` | **[]** |\n| `app/dashboard/layout.js` | `/dashboard/settings` | **['settings']** |\n\n# usePathname\n`usePathname` 훅을 사용하면 [클라이언트 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components)에서 현재 URL pathname을 읽어올 수 있습니다.\n\n*app/page.tsx*\n```tsx\n'use client';\n\nimport { usePathname } from 'next/navigation';\n\nexport default function Page() {\n  // URL이 /blog/hello 인 경우 pathname = '/blog/hello\n  // URL이 /dashboard?v=2 인 경우 pathname = '/dashboard'\n  const pathname = usePathname();\n  \n  return <div>{pathname}</div>;\n}\n```\n\n### 알아두면 좋은 점\n- 이 훅은 [서버 컴포넌트](https://beta.nextjs.org/docs/rendering/server-and-client-components)에서 사용할 수 없습니다. 어떠한 인수도 허용하지 않습니다.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
   "tags": ["nextjs","Client Hook","nextjs13","ver13"],
   "thumbnail": "https://image.dnkdream.com/20221223_0117Fr_20221222_2223Th_fishing-g3862a40b5_640.jpg",
   "createdAt": "2022-12-23 01:45:58.741",
   "updatedAt": "2022-12-23 03:08:13.411"
 },
 {
   "id": "707e61b2-ed00-4a5e-b81c-8ef9649dcf15",
   "category": "잡담",
   "title": "개발 데스크 셋업",
   "body": "장인은 도구를 탓하지 않는다... 는 말은 반은 맞지만 반은 틀린 말인 것 같다.. 적어도 내게는 ㅋㅋ\n물론 도구를 탓할 이유는 없지만 도구를 잘 고르면 편의성 향상, 개발 시간 단축 등 여러모로 도움이 되는 건 사실이니까\n내가 현재 집에서 사용 중인 데스크 셋업을 소개하고자 한다. 그다지 좋은 세팅이라고는 생각하진 않지만 적어도 나에겐 최선의 조건이다.\n\n# 적절한 모니터\n>현재 집에서 사용 중인 모니터는 어느 정도 게임도 겸하기 때문에 **LG Gear 27GN880 QHD 게이밍 모니터**로 선택했다.\n\n![](https://image.dnkdream.com/220703_142148_405345e0d45fd7413420da206)\n\n이 모니터는 4K 는 아니지만 *QHD, 27인치*이며 *144hz* 를 지원한다. *DCI-P3 98%의 색영역*을 갖고 있고 *nVidia G-Sync*를 지원한다(하지만 난 사용할 일이 없지 ㅋ)\n*응답속도도 1ms* 로 딜레이 없는 작업을 보여준다. 개인적으로 매우 만족한다. 더불어 모니터 아래도 자리를 차지하지 않아 참 좋다!\n\n# 썬더볼트 독 with Caldigit TS-3 Plus\n현재 **맥북프로 M1 Pro 14인치**를 사용 중인데 맥 세이프 충전단자를 처음에는 잘 사용했는데 책상 구조를 보면 알겠지만 좌측 케이블, 우측 케이블 하나씩 나와 있으면 뭔가 기분이 멜랑꼴링 할 듯 하여 어차피 갖고 있는 썬더볼트 독 **칼디짓의 TS-3 Plus**를 연결했다.\n이로써 썬더볼트 케이블 하나로 모든 연결이 가능하다. <span style=\"color:rgb(230, 0, 0)\">(← 이게 정말 매우 편리하다)</span>\n![](https://image.dnkdream.com/220703_143016_405345e0d45fd7413420da208)\n\n*패쓰쓰루로 87와트 충전*도 지원하여 그냥 정말 저 케이블 하나면 된다. 현재 TS-4 (썬더볼트4)를 주문해 놓아 배송중인데 도착하면 TS-3 Plus는 사무실에 갖다 놓고 집에서는 TS-4를 쓸 예정이다.\n참고로 *TS-4 는 98와트 패쓰쓰루*를 지원한다. 딱 내 맥북의 필요전력이다! <span style=\"color:rgb(230, 0, 0)\">빨리 사용해 보고 싶다!</span>\n\n![](https://image.dnkdream.com/220703_142924_405345e0d45fd7413420da207)\n\n# 아이폰, 애플워치, 에어팟\n![](https://image.dnkdream.com/220703_143128_405345e0d45fd7413420da209)\n사진에서 보이듯이 아이폰, 애플워치, 에어팟 프로를 사용중인데 **벨킨의 3 in 1 충전기**를 사용 중이다. 이거 정말 편하다.\n편하기도 편하지만 책상 위가 정리정돈 되는 느낌이라 너무 잘 사용 중이다.\n\n## 듀얼센스(?)\n![](https://image.dnkdream.com/220703_143229_405345e0d45fd7413420da20a)\n데스크 셋업은 아니지만 가끔은 게임도 하면서 스트레스도 날려야 한다고 생각한다. 그래서 어떤 패드를 살까 고민하다 **듀얼센스**로 골랐다.\n이것 저것 연결해 보니 <span style=\"color:rgb(230, 0, 0)\">맥북에서 듀얼센스는 생각보다 연결이 정말 잘 되고 사용하는데 편하다!</span>\n맥에서 게임한다는게 좀 웃기긴 하지만 생각보다 에뮬게임이 정말 잘 돌아간다 ㅋㅋㅋ\n# 기타 키보드, 트랙패드\n사진을 따로 찍진 않았지만 코딩할 때나 웹서핑, 파이널 컷 등을 사용할 때는 솔직히 마우스보다 저 미친 성능의 **매직 트랙패드**가 너무 좋다.\n넓직해서 사용하기도 편하고 표면의 질감이나 클릭감, 움직임이 너무 우수해 즐겨 사용한다.\n\n또한 키보드는 맥과 윈도우를 왔다갔다 할 수 있고 유선과 블루투스 연결을 병행할 수 있는 제품들 중 지금까지 사용해 본 경험에 의하면 **키크론 사의 키보드**가 나랑 정말 잘 맞아서 사용 중이다.\n집에서는 소음과 관계가 없으니 청축을 사용, 회사에서는 적축을 사용하며 스위치 하나로 맥과 윈도우의 전환, 유선과 블루투스의 전환이 이루어져 너무너무 편하게 사용 중이다.\n![](https://image.dnkdream.com/220703_143942_405345e0d45fd7413420da20b)\n\n이렇게 내 데스크 셋업을 소개해 봤다. 데스크 셋업의 정석이란 건 없고 내가 사용하기 편하고 효율적이면 그게 최고지만 작업을 얼마나 빠르고 쾌적하게 불편함 없이 할 수 있게 구조를 잡느냐가 관건인 것 같다.\n> 빨리 TS-4 가 왔으면....",
   "tags": ["개발","책상","도구들"],
   "thumbnail": "https://image.dnkdream.com/220703_141754_405345e0d45fd7413420da205",
   "createdAt": "2022-07-02 20:19:39.634",
   "updatedAt": "2022-11-13 06:34:55.259"
 },
 {
   "id": "739d8d60-43d6-4c98-85f7-ced275fde034",
   "category": "Nextjs",
   "title": "Next.js 13 Routing Fundamentals",
   "body": "Next.js 13은 레이아웃, 중첩 라우팅, 로딩 상태, 에러 처리 등을 지원하는 리액트 서버 컴포넌트 위에 구축된 새로운 파일 시스템 기반 라우터를 도입했습니다.\n# Terminology\n![](https://image.dnkdream.com/20221203_2053Sa_terminology-component-tree.webp)\n- `Tree` : 계층 구조를 시각화하기 위한 규칙입니다. 예를 들어, 부모 및 자식 컴포넌트가 있는 컴포넌트 트리, 폴더 구조 등이 있습니다.\n- `Subtree` : 새 루트(첫 번째)에서 시작, Leaf(마지막)에서 끝나는 트리의 일부입니다.\n- `Root` : 루트 레이아웃과 같은 트리 또는 하위 트리의 첫 번째 노드입니다.\n- `Leaf` : URL 경로의 마지막 세그먼트와 같이 자식이 없는 하위 트리의 노드입니다.\n\n\n![](https://image.dnkdream.com/20221203_2053Sa_terminology-url-anatomy.webp)\n- URL Path : 도메인 뒤에 오는 URL의 일부입니다.\n- URL Segment : 슬래시로 구분된 URL 경로의 일부입니다.\n\n# app 디렉토리\n새 라우터는 app 이라는 새 디렉토리에서 작동합니다. app 디렉토리는 점진적 채택을 허용하기 위해 pages 디렉토리와 함께 작동합니다. 이를 통해 애플리케이션의 일부 경로를 새 동작으로 선택하고 다른 경로는 이전 동작에 대해 pages 디렉토리에 보관할 수 있습니다.\n> 알아두면 좋은 점 : 디렉토리 간 경로는 동일한 URL 경로로 확인되어서는 안되며 충돌을 방지하기 위해 빌드시 오류가 발생합니다.\n\n![](https://image.dnkdream.com/20221203_2054Sa_app-folder-page-folder.webp)\n기본적으로 앱 내부의 컴포넌트는 리액트 서버 컴포넌트입니다. 이것은 성능 최적화이며 이를 쉽게 채택할 수 있습니다. 하지만 클라이언트 컴포넌트를 사용할 수도 있습니다.\n> 권장사항 : 서버 컴포넌트를 처음 사용하는 경우 [서버 및 클라이언트 컴포넌트 페이지](https://beta.nextjs.org/docs/rendering/server-and-client-components)를 확인하세요.\n\n# app 내부 폴더와 파일들\n- 폴더는 경로를 정의하는데 사용됩니다. 경로는 루트 폴더에서 최종 리프 폴더까지 계층 구조를 따르는 중첩 폴더의 단일 경로입니다.\n- 파일은 경로 세그먼트에 대해 표시되는 UI를 만드는데 사용됩니다. [특수 파일](https://beta.nextjs.org/docs/routing/fundamentals#special-files)을 참조하세요.\n\n# 라우트 세그먼트\n라우트의 각 폴더는 경로 세그먼트를 나타냅니다. 각 경로 세그먼트는 URL 경로의 해당 세그먼트에 매핑됩니다.\n![](https://image.dnkdream.com/20221203_2056Sa_route-segments-to-path-segments.webp)\n\n# 중첩된 라우트\n중첩된 라우트를 만들려면 폴더를 서로 중첩합니다. 예를 들어 app 디렉토리에 두 개의 새 폴더를 중첩하여 /dashboard/settings 경로를 추가할 수 있습니다.\n\n/dashboard/settings 경로는 세 개의 세그먼트로 구성됩니다.\n\n- / 루트 세그먼트\n- dashboard 세그먼트\n- settings 리프 세그먼트\n\n# 특수 파일들\nNext.js는 라우트에서 사용할 수 있는 일련의 특수 파일들을 제공합니다. 다음과 같습니다.\n![](https://image.dnkdream.com/20221203_2057Sa_special-files.webp)\n- page.tsx : 경로의 고유한 UI를 정의하고 경로를 공개적으로 액세스할 수 있도록 만드는 파일\n- layout.tsx : 여러 페이지에서 공유되는 UI를 정의하는데 사용되는 파일, 레이아웃은 다른 레이아웃이나 페이지를 자식으로 받아들입니다. 레이아웃을 중첩하여 중첩 경로를 만들 수 있습니다.\n- loading.tsx : 앱의 특정 부분에 대한 로딩 UI를 생성하는데 사용되는 선택적(옵션) 파일입니다. React Suspense Boundary에서 페이지 또는 하위 레이아웃을 자동으로 래핑하여 첫 번째 로드 시 및 형제 경로 사이를 탐색할 때 로드 컴포넌트를 즉시 표시합니다.\n- error.tsx : 에러를 앱의 특정 부분으로 격리하고 특정 에러 정보를 표시하고 복구를 시도하는 기능에 사용되는 선택적(옵션) 파일입니다. React Error Boundary에서 페이지 또는 하위 레이아웃을 자동으로 래핑합니다. 하위 트리에서 에러가 발견될 때마다 에러 컴포넌트를 표시합니다.\n- template.tsx : 레이아웃과 유사하지만 탐색 시 컴포넌트의 새 인스턴스가 마운트되고 state가 공유되지 않는 선택적(옵션) 파일입니다. 애니메이션 시작/종료와 같이 이 동작이 필요한 경우 템플릿을 사용할 수 있습니다.\n- head.tsx : 주어진 경로에 대한 &lt;head&gt; 태그의 내용을 정의하는데 사용되는 선택적(옵션) 파일입니다.\n\n> 알아두면 좋은 정보 : js, jsx, tsx 파일 확장자는 특수 파일에 사용할 수 있습니다. ts는 지원 안 됨\n\n# Colocation\n특수 파일 외에도 폴더 내 자신의 파일을 함께 배치할 수 있는 옵션이 있습니다. 예를 들어 스타일시트, 테스트, 컴포넌트 등이 있습니다.\n![](https://image.dnkdream.com/20221203_2058Sa_collocating-assets-in-the-app-directory.webp)\n\n# 클라이언트 측 탐색을 통한 서버 중심 라우팅\n클라이언트 측 라우팅을 사용하는 pages 디렉토리와 달리 app 디렉토리의 새 라우터는 서버 중심 라우팅을 사용하여 서버 컴포넌트 및 서버의 데이터 가져오기에 맞춥니다. 서버 중심 라우팅을 사용하면 클라이언트는 경로 맵을 다운로드 할 필요가 없으며 서버 컴포넌트에 대한 동일한 요청을 사용하여 경로를 조회할 수 있습니다. 이 최적화는 모든 애플리케이션에 유용하지만 경로가 많은 애플리케이션에 더 큰 영향을 미칩니다.\n\n라우팅은 서버 중심이지만 라우터는 SPA 동작과 유사한 Link 컴포넌트와 함게 클라이언트 측 탐색을 사용합니다. 즉, 사용자가 새 경로로 이동할 때 브라우저가 페이지를 다시 로드하지 않습니다. 대신 URL이 업데이트되고 Next.js는 변경된 세그먼트만 렌더링합니다.\n\n또한 사용자가 앱을 탐색할 때 라우터는 리액트 서버 컴포넌트 페이로의 결과를 메모리 내 클라이언트 측 캐싱에 저장합니다. 캐시는 모든 수준에서 무효화를 허용하고 동시 렌더링에서 일관성을 보장하는 경로 세그먼트로 분할됩니다. 이는 특정한 경우에 이전에 가져온 세그먼트의 캐시를 재사용하여 성능을 더욱 향상시킬 수 있음을 의미합니다.\n\n[Link, Navigation 페이지](https://beta.nextjs.org/docs/routing/linking-and-navigating)를 확인하여 Link 컴포넌트 사용법을 확인하세요.\n\n# 부분 렌더링\n형제 경로 사이를 탐색할 때 Next.js는 변경되는 경로의 레이아웃과 페이지만 가져오고 렌더링합니다. 하위 트리의 세그먼트 위에 있는 항목을 다시 가져오거나 다시 렌더링하지 않습니다. 이는 레이아웃을 공유하는 경로에서 사용자가 형제 페이지 사이를 탐색할 때 레이아웃이 유지됨을 의미합니다.\n![](https://image.dnkdream.com/20221203_2059Sa_partial-rendering.webp)\n부분 렌더링이 없으면 탐색할 때마다 전체 페이지가 서버에서 다시 렌더링됩니다. 업데이트 중인 세그먼트만 렌더링하면 전송되는 데이터의 양과 실행 시간이 줄어들어 성능이 향상됩니다.\n\n# 고급 라우팅 패턴\n앞으로 Next.js 라우터는 고급 라우팅 패턴을 구현하는데 도움이 되는 일련의 규칙을 제공할 것입니다. 여기에는 다음이 포함됩니다.\n\n- 병렬 경로\n    - 독립적으로 탐색할 수 있는 동일한 뷰에서 둘 이상의 페이지를 동시에 표시할 수 있습니다. 자체 하위 탐색이 있는 분할 뷰에 사용할 수 있습니다. (예: 대시보드)\n- 가로채기 경로\n    - 경로를 가로채 다른 경로의 컨텍스트에 표시할 수 있습니다. 현재 페이지의 컨텍스트를 유지하는 것이 중요할 때 사용할 수 있습니다. 예를 들어 하나의 작업을 편집하거나 피드에서 사진을 확장하는 동안 모든 작업을 봅니다.\n- 조건부 경로\n    - 조건에 따라 경로를 조건부로 렌더링할 수 있습니다. 예를 들어 사용자가 로그인한 경우에만 페이지를 표시합니다.\n\n이러한 패턴과 규칙을 통해 Next.js 애플리케이션에서 더 풍부하고 복잡한 UI를 구축할 수 있습니다.\n\n아직까진 베타 버전이라 실 적용은 힘들겠지만 빨리 정식으로 나와 써보고 싶네요 ㅎㅎ",
   "tags": ["Nextjs","Next13","Routing"],
   "thumbnail": "https://image.dnkdream.com/20221203_2059Sa_download.png",
   "createdAt": "2022-12-03 20:59:48.233",
   "updatedAt": "2022-12-17 10:24:52.317"
 },
 {
   "id": "73e52852-ec68-4bc1-b56a-3d13b95d2cc5",
   "category": "Nextjs",
   "title": "Next.js 13 API Reference - Font",
   "body": "이 API Reference는 [@next/font/google](https://beta.nextjs.org/docs/api-reference/components/font#nextfontgoogle) 및 [@next/font/local](https://beta.nextjs.org/docs/api-reference/components/font#nextfontlocal)을 사용하는 방법을 이해하는데 도움이 됩니다. 기능 및 사용법은 [Font 최적화](https://beta.nextjs.org/docs/optimizing/fonts) 페이지를 참조하세요.\n\n# 폰트 함수 인수\n사용법은 [구글 폰트](https://beta.nextjs.org/docs/optimizing/fonts#google-fonts) 및 [로컬 폰트](https://beta.nextjs.org/docs/optimizing/fonts#local-fonts)를 확인하세요.\n| Key | `font/google` | `font/local` | Type | Required |\n| --- | --- | --- | --- | --- |\n| [src](https://beta.nextjs.org/docs/api-reference/components/font#src) | ❌ | ✅ | String or Array of Objects | Yes |\n| [weight](https://beta.nextjs.org/docs/api-reference/components/font#weight) | ✅ | ✅ | String or Array | Required/Optional |\n| [style](https://beta.nextjs.org/docs/api-reference/components/font#style) | ✅ | ✅ | String or Array | - |\n| [subsets](https://beta.nextjs.org/docs/api-reference/components/font#subsets) | ✅ | ❌ | Array of Strings | - |\n| [axes](https://beta.nextjs.org/docs/api-reference/components/font#axes) | ✅ | ❌ | Array of Strings | - |\n| [display](https://beta.nextjs.org/docs/api-reference/components/font#display) | ✅ | ✅ | String | - |\n| [preload](https://beta.nextjs.org/docs/api-reference/components/font#preload) | ✅ | ✅ | Boolean | - |\n| [fallback](https://beta.nextjs.org/docs/api-reference/components/font#fallback) | ✅ | ✅ | Array of Strings | - |\n| [adjustFontFallback](https://beta.nextjs.org/docs/api-reference/components/font#adjustfontfallback) | ✅ | ✅ | Boolean or String | - |\n| [variable](https://beta.nextjs.org/docs/api-reference/components/font#variable) | ✅ | ✅ | String | - |\n| [declarations](https://beta.nextjs.org/docs/api-reference/components/font#declarations) | ❌ | ✅ | Array of Objects | - |\n\n## src `필수`\n폰트 파일 경로는 폰트 로더 함수가 호출되는 디렉토리에 상대적인 문자열 또는 객체 배열(`Array<{path: string, weight?: string, style?: string}>` 유형 포함)입니다.\n\n`@next/font/local`에서 사용\n\n*예제*\n- `src:'./fonts/my-font.woff2'`에서 `my-font.woff2` 파일은 `app` 디렉토리 내 `fonts` 라는 디렉토리에 있습니다.\n- `src:[{path: './inter/Inter-Thin.ttf', weight: '100',},{path: './inter/Inter-Regular.ttf', weight: '400',},{path: './inter/Inter-Bold-Italic.ttf', weight: '700', style: 'italic',},]`\n- 폰트 로더 함수가 `src:'../styles/fonts/my-font.ttf'`를 사용해 *app/page.tsx*에서 호출되면 `my-font.ttf`는 프로젝트 루트의 *styles/fonts*에 배치됩니다.\n\n## weight `폰트가 가변적이지 않은 경우 필수`\n사용 가능한 폰트 [weight](https://fonts.google.com/knowledge/glossary/weight)\n- 특정 폰트에 사용할 수 있는 가중치의 가능한 값이 있는 문자열 또는 [가변](https://fonts.google.com/variablefonts) 폰트인 경우 값의 범위\n- 폰트가 [가변 구글 폰트](https://fonts.google.com/variablefonts)가 아닌 경우 가중치 값의 배열입니다. `@next/font/google`에만 적용됩니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `weight: '400'`: 단일 가중치 값에 대한 문자열 - 폰트 [Inter](https://fonts.google.com/specimen/Inter?query=inter)의 경우 가능한 값은 `'100'`, `'200'`, `'300'`, `'400'`, `'500'`, `'600'`, `'700'`, `'800'`, `'900'` 또는 `'변수'`, 여기서는 `'변수'`가 기본값)\n- `weight: '100 900'`: 가변 폰트에 대한 `100`~`900` 범위의 문자열\n- `weight: ['100', '400', '900']`: 비 가변 폰트에 대해 가능한 3가지 값의 배열\n\n## style `선택적`\n사용 가능한 폰트 [style](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style)\n- 기본값이 `normal`인 문자열 [값](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style#values)\n- 폰트가 [변수 구글 폰트](https://fonts.google.com/variablefonts)가 아닌 경우 `style`의 값이 배열입니다. `@next/font/google`에만 적용됩니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `style: 'italic'`: 문자열 - `@next/font/google`의 경우 `normal` 또는 `italic`일 수 있습니다.\n- `style: 'oblique'`: 문자열 - `@next/font/local`에 대한 모든 값을 가질 수 있지만 [표준 폰트 스타일](https://developer.mozilla.org/en-US/docs/Web/CSS/font-style)에서 나올 것으로 예상됩니다.\n- `style: ['italic','normal']`: `@next/font/google`에 대한 2개 값의 배열 - 값은 `normal` 및 `italic`에서 가져옴\n\n## subsets `선택적`\n[Preload](https://beta.nextjs.org/docs/optimizing/fonts#specifying-a-subset) 하려는 각 subset 이름이 있는 문자열 값 배열로 정의된 폰트 [subset](https://fonts.google.com/knowledge/glossary/subsetting) 입니다. subset을 통해 지정된 폰트에는 [preload](https://beta.nextjs.org/docs/api-reference/components/font#preload) 옵션이 true일 때 링크 preload 태그가 헤드에 삽입됩니다. 이는 기본값입니다.\n\n`@next/font/google`에서 사용\n\n*예제*\n- `subsets: ['latin']`: `라틴어` subset이 있는 배열\n\n## axes `선택적`\n일부 가변 폰트에는 포함될 수 있는 `axes`가 있습니다. 기본적으로 파일 크기를 줄이기 위해 폰트 두께만 포함됩니다. 가능한 `axes` 값은 특정 폰트에 따라 다릅니다.\n\n`@next/font/google`에서 사용\n\n*예제*\n- `axes: ['slnt']`: [여기](https://fonts.google.com/variablefonts?vfquery=inter#font-families) 표시된 것처럼 `axes`로 `slnt`가 있는 `Inter` 변수 폰트에 대한 값이 `slnt`인 배열입니다. [구글 가변 폰트 페이지](https://fonts.google.com/variablefonts#font-families)의 필터를 사용하고 `wght` 이외의 축을 찾아 폰트에 가능한 axes 값을 찾을 수 있습니다.\n\n## display `선택적`\n`auto`, `block`, `swap`, `fallback`, `optional`의 가능한 [문자열 값](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display#values)과 기본값 `optional`을 사용해 폰트가 [표시](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display)됩니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `display: 'swap'`: `swap` 값에 할당된 문자열\n\n## preload `선택적`\n폰트를 [미리 로드](https://beta.nextjs.org/docs/optimizing/fonts#preloading)해야 하는지 지정하는 부울 값입니다. 기본값은 `true`입니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `preload: false`\n\n## fallback `선택적`\n폰트를 로드할 수 없는 경우 사용할 대체 폰트입니다. 기본값이 없는 대체 폰트의 문자열 배열입니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `fallback: ['system-ui', 'arial']`: 대체 폰트를 `system-ui` 또는 `arial`로 설정하는 배열\n\n## adjustFontFallback `선택적`\n- `@next/font/google`의 경우: [누적 레이아웃 이동](https://web.dev/cls/)을 줄이기 위해 자동 fallback 폰트를 사용해야 하는지 여부를 설정하는 부울 값입니다. 기본값은 `font`입니다.\n- `@next/font/local`의 경우: [누적 레이아웃 이동](https://web.dev/cls/)을 줄이기 위해 자동 fallback 폰트를 사용해야 하는지 여부를 설정하는 문자열 또는 부울 값(`false`)입니다. 가능한 값은 `Arial`, `Times New Romans`, `false` 입니다. 기본값은 *Arial*입니다.\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `adjustFontFallback: false`: `@next/font/google` 용\n- `adjustFontFallback: 'Times New Romans'`: `@next/font/local` 용\n\n## variable `선택적`\n[CSS 변수 메소드](https://beta.nextjs.org/docs/api-reference/components/font#css-variables)로 스타일을 적용할 경우 사용할 CSS 변수 이름을 정의하는 문자열 값\n\n`@next/font/google`과 `@next/font/local`에서 사용\n\n*예제*\n- `variable: '--my-font'`: CSS 변수 `--my-font`가 선언되었습니다\n\n## declarations\n생성된 @font-face를 추가로 정의하는 [폰트 설명자](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face#descriptors)(키-값 쌍)의 배열입니다.\n\n`@next/font/local`에서 사용\n\n*예제*\n- `declarations: [{ prop: 'ascent-override', value: '90%' }]\n\n# 스타일 적용\n다음 세 가지 방법으로 폰트 스타일을 적용시킬 수 있습니다.\n- [className](https://beta.nextjs.org/docs/api-reference/components/font#classname)\n- [style](https://beta.nextjs.org/docs/api-reference/components/font#style)\n- [CSS Variables](https://beta.nextjs.org/docs/api-reference/components/font#css-variables)\n\n## className\nHTML 엘리먼트에 전달할 로드된 폰트에 대한 read-only CSS className을 리턴합니다.\n```tsx\n<p className={inter.className}>Hello, Next.js!</p>\n```\n\n## style\nFont Family 이름 및 대체(fallback) 폰트에 액세스하기 위한 `style.fontFamily`를 포함 HTML 엘리먼트에 전달할 로드된 폰트에 대한 read-only CSS `style` 객체를 리턴합니다.\n```tsx\n<p style={inter.style}>Hello World</p>\n```\n\n## CSS Variables\n외부 스타일 시트에서 스타일을 설정하고 추가 옵션을 지정하려면 CSS Variables를 사용하세요.\n폰트 가져오기 외 CSS variables가 정의된 CSS 파일도 가져오고 font loader 객체의 변수 옵션을 다음과 같이 설정합니다.\n```tsx\nimport { Inter } from '@next/font/google';\nimport styles from '../styles/component.module.css';\n\nconst inter = Inter({\n  variable: '--font-inter',\n});\n```\n\n폰트를 사용하려면 스타일을 지정하려는 텍스트의 부모 컨테이너의 `className`을 font loader의 `variables` 값으로 설정하고 텍스트의 `className`을 외부 CSS 파일의 `style` 속성으로 설정합니다.\n```tsx\n<main className={inter.variable}>\n  <p className={styles.text}>Hello World</p>\n</main>\n```\n\n다음과 같이 `component.module.css` 파일에서 `text` 셀렉터 클래스를 정의합니다.\n```css\n.text {\n  font-family: var(--font-inter);\n  font-weight: 200;\n  font-style: italic;\n}\n```\n\n위 예제에서 텍스트 `Hello World`는 *Inter 폰트*, *font-weight: 200*, *font-style: italic*으로 생성된 대체(fallback) 폰트를 사용해 스타일이 지정됩니다.",
   "tags": ["nextjs","API","Reference","Font"],
   "thumbnail": "https://image.dnkdream.com/20221221_2028We_20221218_0848Su_alphabet-g6d1c6986b_640.jpg",
   "createdAt": "2022-12-21 20:39:33.597",
   "updatedAt": "2022-12-21 20:39:33.597"
 },
 {
   "id": "801b6fe4-58ae-4274-b1a9-16b5fb478740",
   "category": "Nextjs",
   "title": "React-query Infinite Scroll",
   "body": "이번에 제작한 이 블로그도 그렇고 예전부터 운영해오던 행사전표시스템도 마찬가지이지만 전부 페이징 전환이 없는 무한스크롤링(**Infinite Scroll**)을 사용하고 있다.\n블로그 감성 때문에 페이징을 직접 클릭해 움직이는 것보단 아무래도 별 생각없이 쭈욱쭉 스크롤을 내리면서 글을 읽을 수 있는 점이 무한 스크롤의 큰 장점인데 예전에 구현할 때는 *Redux*, *Apollo* 와 *window의 스크롤 이벤트*를 활용해서 만들었 었고 이는 성능 하락의 원인이 되었었다. 이유는?\n\n> 스크롤을 할 때마다 계속 *의미없는 체킹*을 하게 되니까...\n\n그렇다면 이번엔 어떻게 구현을 할 것인가\n바로 **react-query**의 **useInfiniteQuery**와 자바스크립트의 **Intersection Observer**를 통해서 구현을 해보고자 한다.\n그럼 빠르게 구현해보자.\n\n# 백엔드 설정 (koa.js)\n백엔드는 항상 내가 애용하는 koa.js 로 작성했으며 다른 구조는 무시하고 api 호출만 기록하고자 한다.\n\n*api.ts*\n```jsx\nimport Router from 'koa-router';\nimport { dataSource } from '../server';\nimport Post from '../entities/Post';\n\nconst api = new Router();\n\nasync function listPostsAPI(ctx: Context) {\n  type QueryType = {\n    cursor?: string;\n  };\n\n  const { cursor }: QueryType = ctx.query;\n\n  try {\n    const postsRepo = await ﻿dataSource.getRepository(Post);\n    const query = postsRepo.createQueryBuilder('posts')\n      .limit(30)\n      .orderBy('posts.created_at', 'DESC')\n      .addOrderBy('posts.id', 'DESC');\n    if (cursor) {\n      const post = await postsRepo.findOneBy({ id: cursor });\n      if (!post) {\n        ctx.status = 404;\n        ctx.body = '해당 포스트가 존재하지 않습니다.';\n        ﻿return;\n      };\n      query.andWhere('posts.created_at < :date', {\n        date: post.created_at,\n      });\n      query.orWhere('posts.created_at = :date AND posts.id < :id', {\n        date: post.created_at,\n        id: post.id\n      });\n    };\n    const posts = await query.getMany();\n    ctx.body = posts;\n  } catch(err: any) {\n    ctx.throw(500, err);\n  }\n};\n```\n*cursor* 를 **api query**로 받아서 그 이후의 포스트 목록을 30개를 반환하는 API이다.\n그럼 이어서 프론트엔드를 작성해 보자.\n\n# 프론트엔드 (Nextjs)\nNext js, typescript를 사용할 거고 아래와 같이 설치한다.\n```js\n$ npx create-next-app infinite-scroll-posts --typescript\n```\n이어서 react-query 설치\n```js\n$ npm i react-query\n```\n\n그럼 이제 react-query를 Nextjs에서 사용하기 위한 설정을 하자.\n\n*pages/_app.tsx*\n```jsx\nimport type { AppProps } from 'next/app';\nimport { useState } from 'react';\nimport { QueryClient, QueryClientProvider, Hydrate } from 'react-query';\nimport { ReactQueryDevtools } from 'react-query/devtools';\n\nfunction App({ Component, pageProps }: AppProps) {\n  const [queryClient] = useState(() => new QueryClient());\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Hydrate state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </Hydrate>\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n\nexport default App;\n```\n\n이제 리액트 쿼리 기본 설정이 끝났으니 무한 스크롤을 위한 훅을 하나 만들자.\n\n*hooks/useObserver.ts*\n```jsx\nimport { useEffect, useState } from 'react';\n\ninterface Props {\n  onIntersect: IntersectionObserverCallback;\n  root?: null;\n  rootMargin?: string;\n  threshold?: number;\n}\n\nfunction useObserver({\n  onIntersect,\n  root,\n  rootMargin = '0px',\n  threshold = 0,\n}: Props) {\n  const [target, setTarget] = useState<HTMLElement | null | undefined>(null);\n\n  useEffect(() => {\n    if (!target) return;\n    \n    const observer: IntersectionObserver = new IntersectionObserver(\n      onIntersect,\n      { root, rootMargin, threshold }\n    );\n    observer.observe(target);\n    return () => observer.unobserve(target);\n  }, [onIntersect, root, rootMargin, target, threshold]);\n\n  return { setTarget };\n}\n\nexport default useObserver;\n```\n\n## Intersection Observer? 그게 뭐야?\n![](https://image.dnkdream.com/220627_104839_405345e0d45fd7413420da202)\n**MDN**에 나와있는 [Intersection Observer](https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API)의 설명이다.\n따라서 편하게 생각하자면 다음과 같다.\n대상으로 하는 녀석(*target*)을 **기기의 뷰포트**나 **특정 요소**가 <span style=\"color:rgb(230, 0, 0)\">교차할 때 콜백함수를 실행</span>해 준다 정도로 이해하자\n이 녀석을 이제 적용해 보자.\n\n*pages/index.tsx*\n```jsx\nimport type { NextPage } from 'next';\nimport { useMemo } from 'react';\nimport { useRouter } from 'next/router';\nimport { listPostsAPI } from '../api/posts';\nimport useObserver from '../hooks/useObserver';\n\nconst IndexPage: NextPage = () => {\n  const router = useRouter();\n  /*\n\tpageParam으로 백엔드 cursor 값으로 넣어주고\n\t다음 페이지의 cursor는 들어온 포스트 리스트의 마지막 -1 아이디로 지정하여 api 호출﻿\n  */\n  const { data, fetchNextPage } = useInfiniteQuery(\n    'posts',\n    ({ pageParam }) => listPostsAPI({ cursor: pageParam }),\n    {\n      getNextPageParam: (data) =>\n        data && data.length === 30 ? data[data.length - 1].id : undefined,\n      enabled: true,\n    }\n  );\n\n  /*\n\t포스트의 내용을 계속 이어 붙여줘야 하기 때문에 concat 함수를 사용\n\tdata의 불필요한 연산을 방지하기 위해 useMemo로 저장\n  */\n  const posts = useMemo(() => {\n    if (!data) {\n      return [];\n    }\n    return ([] as PostType[]).concat(...data.pages);\n  }, [data]);\n\n  const onReadPost = (id: string) => {\n    router.push(`/post/${id}`);\n  };\n\n  const onIntersect: IntersectionObserverCallback = ([entry]) => {\n    entry.isIntersecting && fetchNextPage();\n  };\n\n  const { setTarget } = useObserver({ onIntersect });\n\n  return (\n    <div>\n      <h2>포스트 목록</h2>\n      {posts &&\n        posts.length > 0 &&\n        posts.map((post) => (\n          <div key={post.id} onClick={() => onReadPost(post.id)}>\n            {post.title}\n          </div>\n        ))}\n      <div ref={setTarget} />\n    </div>\n  );\n};\n\nexport default IndexPage;\n```\n\n# 라우터 이동 위치 기억\n보통 블로그를 생각해보면 <span style=\"color:rgb(230, 0, 0)\">라우터 또는 next/link</span>를 이용하여 포스트 제목을 클릭하고 포스트의 세부 내용을 본 다음 다시 뒤로 즉, *router.back()* 을 하게 마련이다.\n이 경우 <span style=\"color:rgb(230, 0, 0)\">현재까지 스크롤이 되어 있던 위치가 사라지게 되므로</span> 다시 처음부터 스크롤이 시작될 거다.\n이건 너무 사용자 경험에 있어서 불편함을 주기 때문에 **위치를 기록해 주는 방법**을 마련하자.\n```js\n$ npm install use-local-storage\n```\n로컬 스토리지를 간편하게 사용하게 해주는 라이브러리이다.\n그럼 아래와 같이 코드가 변경된다.\n\n*pages/index.tsx*\n```jsx\n...\nimport useLocalstorage from 'use-local-storage';\n\nconst IndexPage: NextPage = () => {\n  const [scrollY, setScrollY] = useLocalstorage('posts_list', 0);\n\n  // 생략...\n  const onReadPost = (id: string) => {\n    setScrollY(window.scrollY);\n    router.push(/post/<span class=\"hljs-subst\">${id}</span>);\n  };\n\n  useEffect(() => {\n    if (scrollY !== 0) window.scrollTo(0, Number(scrollY));\n  }, []);\n\n  // 생략...\n  return (\n    <div>\n      <h2>포스트 목록</h2>\n      {posts && posts.length > 0 && (\n        posts.map(post => (<div key={post.id}>{post.title}</div>)\n      ))}\n      <div ref={setTarget} />\n    </div>\n...\n```\n\n*onReadPost* 라는 함수로 포스트 내용 보기 페이지로 이동할 때 **setScroll** 로 현재의 스크롤을 저장해주고 이후 라우터를 뒤로 돌려봐도 위치가 **posts_list** 로컬스토리지 값에 기록되어 있으므로 자동으로 그 위치로 돌아가게 된다.",
   "tags": ["react-query","infinite scroll","무한스크롤","리액트"],
   "thumbnail": "https://image.dnkdream.com/220627_101247_405345e0d45fd7413420da201",
   "createdAt": "2022-06-26 16:34:52.016",
   "updatedAt": "2022-11-13 06:34:27.352"
 },
 {
   "id": "96850dc1-e5fe-4ee8-b7dc-60d7f3678d19",
   "category": "취미",
   "title": "Nikon P-1000 달, 태양 촬영 (feat. 카린이)",
   "body": "난 카린이다 ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ\n니콘의 쿨픽스 1000 망원 카메라를 소지하고 있지만 촬영을 무진장 못하고 카메라 지식도 없는 카린이...\n\n그래도 카메라 자체 성능이 괜찮아서 어느 정도의 퀄리티는 뽑아준다.\n\n# 달 촬영\n내 거주지가 행신역 부근이라 근방에서 촬영을 많이 하고 혹여 여행을 가거나 하면 그곳에서도 촬영을 하려고 노력한다. 하지만 구름 좌식이 항상 내 시야를 가리곤 해서 못 찍고 돌아오는 경우가 허다하다.\n\n그 동안 촬영한 사진들을 나열해 보자면\n\n## 7. 15. 행신역 부근\n![](https://image.dnkdream.com/20221223_0406Fr_7.%2015.%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%20%E1%84%83%E1%85%A1%E1%86%AF.JPG)\n새벽 5시경 행신역 건물 너머로 보이는 달을 자차 창문을 살짝 열고 줌을 땡겨 찍은 사진이다. 뽀얗고 이쁘게 나왔다. ㅎㅎㅎ\n\n![](https://image.dnkdream.com/20221223_0407Fr_7.%2015.%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%20%E1%84%83%E1%85%A1%E1%86%AF2.JPG)\n위치만 살짝 이동해서 다시 확대 촬영한 사진이다.\n\n![](https://image.dnkdream.com/20221223_0407Fr_7.%2015.%20%E1%84%8B%E1%85%A1%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%83%E1%85%A1%E1%86%AF.JPG)\n조금 더 새벽 녘에 거주 중인 아파트 지붕 너머로 걸친 달 사진이다. 뭔가 운치있고 분위기 있어 보여 찍어봤다.\n\n## 11. 5. 행신역 부근\n![](https://image.dnkdream.com/20221223_0408Fr_11.%208.%20%E1%84%92%E1%85%A2%E1%86%BC%E1%84%89%E1%85%B5%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%A8%20%E1%84%83%E1%85%A1%E1%86%AF.JPG)\n\n## 11. 7. 행신역 부근\n![](https://image.dnkdream.com/20221223_0409Fr_11.%208.%20%E1%84%83%E1%85%A1%E1%86%AF.JPG)\n\n## 11. 8. 용산역 부근\n![](https://image.dnkdream.com/20221223_0409Fr_11.%209.%20%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%89%E1%85%A1%E1%86%AB%20%E1%84%83%E1%85%A1%E1%86%AF.JPG)\n\n이렇게 계속 평범한 달을 촬영하다 결국 그 날이 왔다.\n\n200년 후에나 다시 볼 수 있는 전설의 *개기월식*!!\n그 이름 `레드문`!!!!\n\n물론 촬영 배경지식이 별로 없어 제대로 찍은 건 아니지만 나도 남겼다. ㅎㅎ 역사에 길이길이 남으리~\n![](https://image.dnkdream.com/20221223_0413Fr_%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%83%E1%85%B3%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8C%E1%85%A5%E1%86%AB.JPG)\n아직 레드문이 머리를 빼꼼 내밀고 있을 순간\n\n![](https://image.dnkdream.com/20221223_0413Fr_%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%83%E1%85%B3%E1%86%BC%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%92%E1%85%AE.JPG)\n망원 렌즈로 확대한 사진.\n반사되는 빛 량이 적어서 그런가 평소때처럼 선명한 촬영이 많이 힘들었다.\n\n![](https://image.dnkdream.com/20221223_0414Fr_%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%E1%84%86%E1%85%AE%E1%86%AB%20%E1%84%8B%E1%85%A1%E1%84%91%E1%85%A1%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%A3%E1%86%BA.JPG)\n특히 이 사진을 찍고 소름이 돋았었는데 사실 저 사진을 찍는 순간 달은 육안으로 봤을 때는 분명히 *거무죽죽한 상태*였다.\n근데 카메라를 들이대고 촬영을 하니 저렇게 그림처럼 나왔다... 이 무슨...-0-\n\n# 태양 촬영\n태양은 사실 촬영이 무지 어렵다. 전용 필름이 필요하기도 하고 촬영하기 위한 초점이라던지 노출량이라던지 그런 세밀한 조정도 잘 할 줄 모르는데 하려니 참 어려웠다.\n하지만 내가 일하고 있는 우리 사무실 창문에 썬팅 필름이 코팅되어 있어 그 위로 촬영을 해보니 어느정도 촬영이 가능했다.\n많지는 않지만 사진도 첨부해본다.\n![](https://image.dnkdream.com/20221223_0416Fr_8.%204.%20%E1%84%90%E1%85%A2%E1%84%8B%E1%85%A3%E1%86%BC.JPG)\n![](https://image.dnkdream.com/20221223_0416Fr_7.%2029.%20%E1%84%90%E1%85%A2%E1%84%8B%E1%85%A3%E1%86%BC.JPG)\n\n개인적으론 첫번째 태양 사진을 찍었을 때가 가장 멋있었던 것 같다.\n실제 내 눈으로 본 태양이란 정말...\n\n마지막으로 달 촬영 사진 및 동영상을 편집해서 유튜브에 업로드한 영상이 있어 기록해본다.\n\n<iframe class=\"ql-video\" frameborder=\"0\" allowfullscreen=\"true\" src=\"https://www.youtube.com/embed/Gk8TdpH9cU0\"></iframe>",
   "tags": ["Nikon","P-1000","쿨픽스","달촬영","달"],
   "thumbnail": "https://image.dnkdream.com/20221223_0404Fr_11.%208.%20%E1%84%83%E1%85%A1%E1%86%AF.JPG",
   "createdAt": "2022-12-23 04:19:55.669",
   "updatedAt": "2022-12-23 04:19:55.669"
 },
 {
   "id": "9c74776c-4dad-4019-86f8-25d3de328ad3",
   "category": "Nextjs",
   "title": "Next.js 13 API Reference - Image",
   "body": "이 API 레퍼런스는 `<Image>` 컴포넌트에 사용할 수 있는 [props](https://beta.nextjs.org/docs/api-reference/components/image#props) 및 [구성 옵션](https://beta.nextjs.org/docs/api-reference/components/image#configuration-options)을 사용하는 방법을 이해하는데 도움이 됩니다.\n기능 및 사용방법은 [Image 컴포넌트](https://beta.nextjs.org/docs/optimizing/images) 페이지를 참조하세요.\n\n*app/page.tsx*\n```tsx\nimport Image from 'next/image';\n\nexport default function Page() {\n  return (\n    <Image\n      src=\"/profile.png\"\n      width={500}\n      height={500}\n      alt=\"Picture of the author\"\n    />\n  );\n};\n```\n\n# Props\n아래 표는 Image 컴포넌트의 Props 요약입니다.\n| Props | Example | Type | Required |\n| --- | --- | --- | --- |\n| [**src**](https://beta.nextjs.org/docs/api-reference/components/image#src) | `src=\"/profile.png\"` | String | Yes |\n| [**width**](https://beta.nextjs.org/docs/api-reference/components/image#width) | `width={500}` | Integer (px) | Yes |\n| [**height**](https://beta.nextjs.org/docs/api-reference/components/image#height) | `height={500}` | Integer (px) | Yes |\n| [**alt**](https://beta.nextjs.org/docs/api-reference/components/image#alt) | `alt=\"Picture of the author\"` | String | Yes |\n| [**loader**](https://beta.nextjs.org/docs/api-reference/components/image#loader) | `loader={imageLoader}` | Function | - |\n| [**fill**](https://beta.nextjs.org/docs/api-reference/components/image#fill) | `fill={true}` | Boolean | - |\n| [**sizes**](https://beta.nextjs.org/docs/api-reference/components/image#sizes) | `sizes=\"(max-width: 768px) 100vw\"` | String | - |\n| [**quality**](https://beta.nextjs.org/docs/api-reference/components/image#quality) | `quality={80}` | Integer (1-100) | - |\n| [**priority**](https://beta.nextjs.org/docs/api-reference/components/image#priority) | `priority={true}` | Boolean | - |\n| [**placeholder**](https://beta.nextjs.org/docs/api-reference/components/image#placeholder) | `placeholder=\"blur\"` | String | - |\n| [**style**](https://beta.nextjs.org/docs/api-reference/components/image#style) | `style={{ objectFit: \"contain\" }}` | Object | - |\n| [**onLoadingComplete**](https://beta.nextjs.org/docs/api-reference/components/image#onloadingcomplete) | `onLoadingComplete={img => done()}`| Function | - |\n| [**onLoad**](https://beta.nextjs.org/docs/api-reference/components/image#onload) | `onLoad={event => done()}` | Function | - |\n| [**onError**](https://beta.nextjs.org/docs/api-reference/components/image#onerror) | `onError={event => fail()}` | Function | - |\n| [**loading**](https://beta.nextjs.org/docs/api-reference/components/image#loading) | `loading=\"lazy\"` | String | - |\n| [**blurDataURL**](https://beta.nextjs.org/docs/api-reference/components/image#blurdataurl) | `blurDataURL=\"data:image/jpeg...\"` | String | - |\n\n## 필수 Props\n`<Image>` 컴포넌트는 다음의 속성을 필요로 합니다 : *src*, *width*, *height*, *alt*\n\n### src\n*src*는 아래 중 하나여야 합니다.\n- 로컬에서 import 한 이미지 파일\n- 경로 문자열. 이것은 외부 URL 또는 내부 경로일 수 있습니다.\n\n> 외부 URL을 사용할 경우 `next.config.js`의 *remotePatterns* 옵션을 추가해야 합니다.\n\n### width\n*width* 속성은 렌더링된 너비를 픽셀 단위로 나타냅니다.\n[로컬 이미지](https://beta.nextjs.org/docs/optimizing/images#local-images) 또는 [`fill` 속성](https://beta.nextjs.org/docs/api-reference/components/image#fill)이 있는 이미지를 제외하고 이 속성은 필수입니다.\n\n### height\n*height* 속성은 렌더링된 높이를 픽셀 단위로 나타냅니다.\n[로컬 이미지](https://beta.nextjs.org/docs/optimizing/images#local-images) 또는 [`fill` 속성](https://beta.nextjs.org/docs/api-reference/components/image#fill)이 있는 이미지를 제외하고 이 속성은 필수입니다.\n\n### alt\n*alt* 속성은 스크린 리더 및 검색 엔진용 이미지를 설명하는데 사용합니다. 또한 이미지가 비활성화되었거나 이미지를 로드하는 동안 에러가 발생할 경우 대체되는 문자열입니다.\n[페이지의 의미를 변경하지 않고 이미지를 대체](https://html.spec.whatwg.org/multipage/images.html#general-guidelines)할 수 있는 문자열을 포함해야 합니다. 이미지를 보완하기 위한 것이 아니며 위 또는 아래 캡션에 이미 제공된 정보를 반복해서는 안됩니다.\n이미지가 순전히 장식용이거나 사용자용이 아닌 경우 *alt* 속성은 빈 문자열(`alt=\"\"`)이어야 합니다.\n[alt 속성](https://html.spec.whatwg.org/multipage/images.html#alt)에 대해 자세히 알아보세요.\n\n## 선택적 Props\n`<Image>` 컴포넌트는 여러 선택적인 속성을 허용합니다.\n\n### loader\n이미지 URL을 확인하는데 사용하는 지정 함수입니다.\n*loader*는 이미지에 대한 URL 문자열을 리턴하는 함수입니다.\n다음의 매개 변수들을 허용합니다: `src`, `width`, `quality`\n\n*app/page.tsx*\n```tsx\nimport Image from 'next/image';\n\nconst imageLoader = ({ src, width, quality }) => {\n  return `https://example.com/${src}?w=${width}&q=${quality || 75}`;\n}\n\nexport default function Page({ imageLoader }) {\n  return (\n    <Image\n      loader={imageLoader}\n      src=\"/me.png\"\n      alt=\"Picture of the author\"\n      width={500}\n      height={500}\n    />\n  );\n};\n```\n\n### fill\n```js\nfill={true} // Boolean\n```\n[width](https://beta.nextjs.org/docs/api-reference/components/image#width)와 [height](https://beta.nextjs.org/docs/api-reference/components/image#height)를 설정하는 대신 이미지가 상위 엘리먼트(부모)를 채우도록 하는 부울 값입니다.\n기본적으로 `<img>` 엘리먼트에는 *position: \"absolute\"* 가 자동으로 할당됩니다. 상위 엘리먼트(부모)는 *position: \"relative\"*, *position: \"fixed\"*, *position: \"absolute\"* 를 지정해야 합니다.\n기본 이미지 맞춤 동작(`fit behavior`)는 컨테이너에 맞게 이미지를 늘립니다. 컨테이너에 맞고 종횡비를 유지하기 위해 레터박스 처리된 이미지에 대해 *object-fit: \"contain\"* 을 설정하는 것이 좋습니다.\n또는 *object-fit: \"cover\"* 는 이미지가 전체 컨테이너를 채우고 종횡비를 유지하기 위해 크롭됩니다. 올바르게 표시하려면 *overflow: \"hidden\"* 을 상위 엘리먼트(부모)에 지정해야 합니다.\n\n자세한 내용은 [position](https://developer.mozilla.org/en-US/docs/Web/CSS/position), [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit), [object-position](https://developer.mozilla.org/en-US/docs/Web/CSS/object-position)을 참조하세요.\n\n### sizes\n다양한 브레이크 포인트에서 이미지의 너비에 대한 정보를 제공하는 문자열입니다. *sizes* 값은 `fill` 또는 반응형으로 지정된 이미지의 성능에 큰 영향을 미칩니다.\n*sizes* 속성은 이미지 성능과 관련된 두 가지 중요한 목적을 제공합니다.\n- 첫째, `sizes` 값은 브라우저에서 다운로드할 이미지 크기를 결정하는데 사용되며, **next/image**로 설정된 자동 생성소스에서 사용됩니다. 브라우저가 선택할 때 페이지에 있는 이미지의 크기를 아직 알지 못하므로 뷰포트와 같거나 더 큰 이미지를 선택합니다. `sizes` 속성을 사용하면 이미지가 실제로 전체 화면보다 작을 것이라고 브라우저에 알릴 수 있습니다. `fill` 속성으로 이미지의 크기 값을 지정하지 않으면 기본값인 100vw(`전체 화면 너비`)가 사용됩니다.\n- 둘째, `sizes` 속성은 **next/image**가 이미지 소스세트를 자동으로 생성하는 방법을 구성합니다. 만약 `sizes` 값이 없다면 고정 크기 이미지에 적합한 작은 소스세트가 생성됩니다. `sizes` 가 정의되면 반응형 이미지에 적합한 큰 소스세트가 생성됩니다. `sizes` 속성에 뷰 포트 너비의 백분율을 나타내는 `50vw`와 같은 크기가 포함된 경우 너무 작아서 필요하지 않은 값을 포함하지 않도록 소스세트가 트림됩니다.\n\n예를 들어 스타일 지정으로 이미지가 `모바일`에서는 *전체 너비*, `태블릿`에서는 *2열 레이아웃*, `데스크탑`에서는 *3열 레이아웃*이 된다는 것을 알고 있는 경우 아래와 같이 `sizes` 속성을 포함해야 합니다.\n\n*app/page.tsx*\n```tsx\nimport Image from 'next/image';\n\nexport default function Page() {\n  return (\n    <div className=\"grid-element\">\n      <Image\n        src=\"/example.png\"\n        layout=\"fill\"\n        sizes=\"(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw\"\n      />\n    </div>\n  );\n};\n```\n\n이 예제 `sizes`는 성능 메트릭에 영향을 미칠 수 있습니다. *33vw*가 없으면 서버에서 선택한 이미지의 너비가 필요한 너비의 **3배**가 됩니다. 파일 크기는 너비의 제곱에 비례하므로 `sizes` 가 없다면 사용자는 필요 수치보다 9배가 더 큰 이미지를 다운로드합니다.\n\n[**srcset**](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-srcset) 및 [**sizes**](https://web.dev/learn/design/responsive-images/#sizes)에 대해 자세히 알아보세요.\n\n### quality\n```js\nquality={75} // {number 1-100}\n```\n최적화된 이미지의 품질은 1에서 100 사이의 정수입니다. 여기서 100은 최상의 품질이므로 가장 큰 파일 크기이며 기본값은 **75**입니다.\n\n### priority\n```js\npriority={false} // Boolean\n```\n`{true}`일 경우 이미지는 높은 우선 순위 및 preload로 간주됩니다. `priority`를 사용하는 이미지에 대해서는 *Lazy Loading*이 자동으로 비활성화됩니다.\n**LCP(Largest Contentful Paint)** 엘리먼트로 감지된 모든 이미지에 `priority` 속성을 사용해야 합니다. 서로 다른 이미지가 서로 다른 뷰 포트 크기에 대한 LCP 엘리먼트일 수 있으므로 여러 개의 우선 순위 이미지를 갖는 것이 적절할 수 있습니다.\n`priority` 속성은 접힌 부분 위 이미지가 표시될 때만 사용해야 합니다. 기본값은 `{false}` 입니다.\n\n### placeholder\n```js\nplaceholder = \"empty\"; // {empty} || {blur}\n```\n이미지가 로드되는 동안 사용할 *자리 표식*입니다. 가능한 값은 `blur`, `empty`이며 기본값은 `empty`입니다.\n`blur`를 사용할 때 `blurDataURL` 속성이 *placeholder*로 사용됩니다. `src`가 로컬 이미지이고 가져온 이미지가 `.jpg, .png, .webp, .avif`인 경우 `blurDataURL`이 자동으로 채워집니다.\n동적 이미지의 경우 `blurDataURL` 속성을 제공해야 합니다. *placeholder* 같은 솔루션은 `base64` 생성에 도움이 될 수 있습니다.\n`empty`를 사용하면 이미지가 로드되는 동안 *placeholder*가 없이 빈 자리만 있습니다.\n- [`blur` placeholder 데모](https://image-component.nextjs.gallery/placeholder)\n- [`blurDataURL` 속성 shimmer 이펙트 데모](https://image-component.nextjs.gallery/shimmer)\n- [`blurDataURL` 속성 color 이펙트 데모](https://image-component.nextjs.gallery/shimmer)\n\n### style\n기본 이미지 엘리먼트에 [css styles](https://reactjs.org/docs/dom-elements.html#style)를 전달할 수 있습니다.\n\n*components/ProfileImage.tsx*\n```tsx\nconst imageStyle = {\n  borderRadius: '50%',\n  border: '1px solid #666',\n};\n\nexport default function ProfileImage() {\n  return <Image src=\"...\" style={imageStyle} />;\n}\n```\n필요한 너비 및 높이 Props가 *style*과 상호 작용할 수 있음을 기억하세요. *style*을 사용하여 이미지의 너비를 수정하는 경우 고유 종횡비를 유지하기 위해 높이를 `auto`로 지정해야 합니다. 그렇지 않으면 이미지가 왜곡됩니다.\n\n### onLoadingComplete\n```tsx\n<Image onLoadingComplete={callbackFn} />\n```\n이미지가 완전히 로드되고 `placeholder`가 제거되면 호출되는 콜백 함수입니다.\n콜백 함수는 기본 `<img>` 엘리먼트에 대한 참조인 하나의 인수(`argument`)로 호출됩니다.\n\n### onLoad\n```tsx\n<Image onLoad={callbackFn} />\n```\n이미지가 로드될 때 호출되는 콜백 함수입니다.\n`placeholder`가 제거되고 이미지가 완전히 디코딩되기 전에 로드 이벤트가 발생할 수 있습니다.\n대신 [onLoadingComplete](https://beta.nextjs.org/docs/api-reference/components/image#onloadingcomplete)를 사용하세요.\n\n### onError\n```tsx\n<Image onError={callbackFn} />\n```\n이미지 로드에 실패하면 호출되는 콜백 함수입니다.\n\n### loading\n> 권장사항 : 이 속성은 고급 사용 사례에만 사용됩니다. `Eager`로 로드하도록 이미지를 전환하면 일반적으로 성능이 저하됩니다. 대부분의 사용 사례에서 이미지를 `preload`하는 `priority`를 대신 사용하는 것이 좋습니다.\n```js\nloading = 'lazy'; // {lazy} | {eager}\n```\n이미지의 로드 동작입니다. 기본값은 `lazy`입니다.\n`lazy`인 경우 뷰 포트에서 계산된 값에 도달할 때까지 이미지 로딩을 연기합니다.\n`eager`인 경우 이미지를 즉시 로드합니다.\n\n[로딩 속성](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-loading)에 대해 자세히 알아보세요.\n\n### blurDataURL\nsrc 이미지가 성공적으로 로드되기 전 `placeholder` 이미지로 사용될 [데이터 URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs)입니다. [`placeholder=\"blur\"`](https://beta.nextjs.org/docs/api-reference/components/image#placeholder)와 결합된 경우에만 적용됩니다.\n`base64`로 인코딩된 이미지여야 합니다. 확대되고 흐려지기 대문에 아주 작은 이미지(10px 이하)를 권장합니다. 더 큰 이미지를 `placeholder`로 포함하면 앱 성능이 저하될 수 있습니다.\n- [기본 `blurDataURL` props 데모](https://image-component.nextjs.gallery/placeholder)\n- [`blurDataURL` Props로 shimmer 이펙트 데모](https://image-component.nextjs.gallery/shimmer)\n- [`blurDataURL` Props로 color 이펙트 데모](https://image-component.nextjs.gallery/color)\n이미지의 일치하도록 [단색 데이터 URL을 생성](https://png-pixel.com/)할 수도 있습니다.\n\n### unoptimized\n```js\nunoptimized = {false} // Boolean\n```\n`true`인 경우 소스 이미지는 품질, 크기 또는 형식을 변경하는 대신 그대로 제공됩니다. 기본값은 `false`입니다.\n다음 구성으로 *next.config.js*를 업데이트하여 이 Props를 모든 이미지에 할당할 수도 있습니다.\n```js\nmodule.exports = {\n  images: {\n    unoptimized: true,\n  },\n};\n```\n\n## 다른 Props\n`<Image />` 컴포넌트의 다른 속성은 다음을 제외하고 기본 `<img>` 엘리먼트로 전달됩니다.\n- `srcSet`: [Device Sizes](https://beta.nextjs.org/docs/api-reference/components/image#devicesizes) 대신 사용\n- `ref`: [onLoadingComplete](https://beta.nextjs.org/docs/api-reference/components/image#onloadingcomplete) 대신 사용\n- `decoding`: 항상 `async`\n\n# 구성 옵션\nProps 외에도 `next.config.js`에서 이미지 컴포넌트를 구성할 수 있습니다. 다음 옵션을 사용할 수 있습니다.\n\n## remotePatterns\n악의적인 사용자로부터 애플리케이션을 보호하려면 외부 이미지를 사용하기 위한 구성이 필요합니다. 이렇게 하면 계정의 외부 이미지만 Next.js 이미지 최적화 API에서 제공될 수 있습니다. 이러한 외부 이미지는 아래와 같이 *next.config.js* 파일의 `remotePatterns` 속성으로 구성할 수 있습니다.\n\n*next.config.js*\n```js\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: 'example.com',\n        port: '',\n        pathname: '/account123/**',\n      },\n    ],\n  },\n};\n```\n\n위 예제는 `next/image`의 `src`속성이 *https:\\/\\/example.com/account123/* 으로 시작하도록 합니다. 다른 프로토콜, 호스트 이름, 포트 또는 일치하지 않는 경로는 **400 Bad Request**으로 응답합니다.\n아래 예제는 *next.config.js* 의 `remotePatterns` 속성의 또 다른 예입니다.\n```tsx\nmodule.exports = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: 'https',\n        hostname: '**.example.com',\n      },\n    ],\n  },\n};\n```\n위 예제는 `next/image`의 `src`속성이 여러 하위 도메인들과 함께 *example.com* 도메인을 사용하도록 합니다.(예: *https:\\/\\/img1.example.com*) 다른 프로토콜이나 일치하지 않는 호스트 이름은 **400 Bad Request**로 응답합니다.\n와일드 카드 패턴은 `pathname`, `hostname` 모두에 사용할 수 있으며 다음 구문을 사용합니다.\n- *: 단일 경로 세그먼트 또는 하위 도메인과 일치\n- **: 끝에 있는 임의의 경로 세그먼트 또는 시작 부분에 있는 하위 도메인과 일치\n\n** 구문은 패턴 중간에서 작동하지 않습니다.\n\n## domains\n> 권장 사항: *protocol* 및 *pathname*을 제한할 수 있도록 [remotePatterns](https://beta.nextjs.org/docs/api-reference/components/image)를 대신 사용하세요.\n\n`remotePatterns`와 유사하게 도메인 구성을 사용하여 외부 이미지에 허용된 호스트 이름 목록을 제공할 수 있습니다.\n하지만 도메인 구성은 와일드카드 패턴 일치를 지원하지 않으며 `protocol`, `port`, `pathname`을 제한할 수 없습니다.\n다음은 *next.config.js*에 있는 `domains` 속성의 예제입니다.\n```js\nmodule.exports = {\n  images: {\n    domains: ['assets.example.com'],\n  },\n};\n```\n\n# 고급 구성 옵션\n다음 구성은 고급 사용 사례를 위한 것이며 일반적으로 필요하지 않습니다. 아래 속성을 구성하도록 선택하면 향후 업데이트에서 *Next.js* 기본값에 대한 모든 변경사항을 재정의합니다.\n\n## deviceSizes\n사용자의 디바이스 예상 너비를 알고 있는 경우 *next.config.js* 의 `deviceSizes` 속성을 사용하여 장치 너비 브레이크 포인트를 지정할 수 있습니다. 이러한 너비는 `next/image` 컴포넌트가 `sizes` Props를 사용해 사용자 디바이스에 올바른 이미지가 제공되도록 할 때 사용합니다.\n구성이 제공되지 않으면 아래의 기본값이 사용됩니다.\n\n*next.config.js*\n```js\nmodule.exports = {\n  images: {\n    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  },\n};\n```\n\n## imageSizes\n*next.config.js* 의 `images.imageSizes` 속성을 사용해 이미지 너비 목록을 지정할 수 있습니다. 이러한 너비는 디바이스 크기 배열과 연결되어 이미지 `srcsets`를 생성하는데 사용되는 크기의 전체 배열을 형성합니다.\n두 개의 개별 목록이 있는 이유는 `imageSizes`가 이미지가 화면의 전체 너비보다 작음을 나타내는 `sizes` Props를 제공하는 이미지에만 사용되기 때문입니다. **따라서 `imageSizes`의 크기는 모두 `deviceSizes`의 가장 작은 크기보다 작아야 합니다.**\n구성이 제공되지 않으면 아래의 기본값이 사용됩니다.\n\n*next.config.js*\n```js\nmodule.exports = {\n  images: {\n    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],\n  },\n};\n```\n\n## formats\n기본 [이미지 최적화 API](https://beta.nextjs.org/docs/api-reference/components/image#loader)는 요청의 `Accept` 헤더를 통해 브라우저에서 지원하는 이미지 형식을 자동으로 감지합니다.\n`Accept` 헤드가 구성된 형식 중 둘 이상과 일치하는 경우 배열의 첫 번째 일치 항목이 사용됩니다. 따라서 배열의 순서가 중요합니다. 일치하는 항목이 없는 경우(또는 소스 이미지가 [애니메이션](https://beta.nextjs.org/docs/api-reference/components/image#animated-images) 된 경우) 이미지 최적화 API는 원본 이미지의 형식으로 fallback합니다.\n구성이 제공되지 않으면 아래의 기본값이 사용됩니다.\n\n*next.config.js*\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/webp'],\n  },\n};\n```\n다음 구성으로 AVIF 지원을 활성화할 수 있습니다.\n```js\nmodule.exports = {\n  images: {\n    formats: ['image/avif', 'image/webp'],\n  },\n};\n```\n\n**알아두면 좋은 점**:\n- AVIF는 일반적으로 인코딩하는데 20% 더 오래 걸리지만 압축률은 WebP에 비해 20% 더 작습니다. 즉, 이미지가 처음 요청될 때 일반적으로 속도가 느리고 캐시된 후속 요청이 더 빠릅니다.\n- Next.js 앞에 Proxy/CDN을 사용해 자체 호스트 하는 경우 `Accept` 헤더를 전달하도록 Proxy를 구성해야 합니다.\n\n# 캐싱 동작\n다음은 기본 [loader](https://beta.nextjs.org/docs/api-reference/components/image#loader)에 대한 캐싱 알고리즘을 설명합니다. 다른 모든 loader 에 대해서는 클라우드 공급자의 설명서를 참조하세요.\n\n이미지는 요청 시 동적으로 최적화되며 `<distDir>/cache/images` 디렉토리에 저장됩니다. 만료될 때까지 후속 요청에 대해 최적화된 이미지 파일이 제공됩니다. 캐시되었지만 만료된 파일과 일치하는 요청이 생성되면 만료된 이미지가 즉시 오래된 상태로 제공됩니다. 이 후 이미지가 백그라운드에서 다시 최적화되고(재검증이라고도 함) 새 만료 날짜와 함께 캐시에 저장됩니다.\n\n이미지의 캐시 상태는 `x-nextjs-cache` 응답 헤더의 값을 읽어서 확인할 수 있습니다. 가능한 값은 다음과 같습니다.\n- `MISS` - 경로가 캐시에 없습니다(처음 방문할 때 최대 한 번 발생)\n- `STALE` - 경로가 캐시에 있지만 재검증 시간을 초과해 백그라운드 업데이트\n- `HIT` - 경로가 캐시에 있고 유효성 재검사 시간을 초과하지 않습니다.\n\n만료(또는 Max Age)는 [minimumCacheTTL](https://beta.nextjs.org/docs/api-reference/components/image#minimum-cache-ttl) 구성 또는 업스트림 이미지 Cache-Control 헤더 중 더 큰 것으로 정의됩니다. 특히 `Cache-Control` 헤더의 `max-age` 값이 사용됩니다. `s-maxage`와 `max-age`가 모두 발견되면 `s-maxage`가 선호됩니다. `max-age`는 CDN 및 브라우저를 포함한 모든 다운스트림 클라이언트에도 전달됩니다.\n- 업스트림 이미지에 `Cache-Control` 헤더가 포함되어 있지 않거나 값이 매우 낮은 경우 캐시 기간을 늘리도록 [minimumCacheTTL](https://beta.nextjs.org/docs/api-reference/components/image#minimum-cache-ttl)을 구성할 수 있습니다.\n- 가능한 총 이미지 수를 줄이기 위해 [deviceSizes](https://beta.nextjs.org/docs/api-reference/components/image#devicesizes) 및 [imageSizes](https://beta.nextjs.org/docs/api-reference/components/image#imagesizes)를 구성할 수 있습니다.\n- 단일 이미지 형식을 위해 여러 형식을 비활성화하도록 [형식](https://beta.nextjs.org/docs/api-reference/components/image#formats)을 구성할 수 있습니다.\n\n## minimumCacheTTL\n캐시된 최적화 이미지의 TTL(Time to Live)을 초 단위로 구성할 수 있습니다. 대부분의 경우 파일 내용을 자동으로 해시하고 불변(`immutable`)의 `Cache-Control` 헤더로 이미지를 영원히 캐시하는 [로컬 이미지](https://beta.nextjs.org/docs/optimizing/images#local-images)를 사용하는 것이 좋습니다.\n\n*next.config.js*\n```js\nmodule.exports = {\n  images: {\n    minimumCacheTTL: 60,\n  },\n};\n```\n최적화된 이미지의 만료(또는 Max Age)는 `minimumCacheTTL` 또는 업스트림 이미지 `Cache-Control` 헤더 중 더 큰 것으로 정의됩니다.\n이미지당 캐싱 동작을 변경해야 하는 경우 업스트림 이미지에 `Cache-Control` [헤더](https://beta.nextjs.org/docs/api-reference/next.config.js/headers)를 설정하도록 헤더를 구성할 수 있습니다.\n(예: /_next/image 자체가 아닌 /some-assets.jpg)\n현재 캐시를 무효화하는 메커니즘이 없으므로 `minimumCacheTTL`을 낮게 유지하는 것이 가장 좋습니다. 그렇지 않으면 `src` props를 수동으로 변경하거나 `<distDir>/cache/images`를 삭제해야 할 수 있습니다.\n\n## disableStaticImports\n기본 동작을 사용하면 `'./icon.png'`에서 import 아이콘과 같은 정적 파일을 가져온 다음 `src` 속성에 전달할 수 있습니다.\n경우에 따라 가져오기가 다르게 작동할 것으로 예상하는 다른 플러그인과 충돌하는 경우 이 기능을 비활성화할 수 있습니다.\n*next.config.js* 내에서 정적 이미지 가져오기를 비활성화할 수 있습니다.\n```js\nmodule.exports = {\n  images: {\n    disableStaticImages: true,\n  },\n};\n```\n\n## dangerouslyAllowSVG과 contentSecurityPolicy\n기본 [loader](https://beta.nextjs.org/docs/api-reference/components/image#loader)는 몇 가지 이유로 SVG 이미지를 최적화하지 않습니다.\n첫째로 SVG는 손실 없이 크기를 조정할 수 있는 벡터 형식입니다.\n둘째로 SVG에는 HTML과 동일한 기능이 많이 있어 적절한 [컨텐츠 보안 정책(CSP)](https://beta.nextjs.org/docs/advanced-features/security-headers) 헤더가 없으면 취약성이 발생할 수 있습니다.\n기본 이미지 최적화 API로 SVG 이미지를 제공해야 하는 경우 *next.config.js*내에서 `dangerouslyAllowSVG` 및 `contentSecurityPolicy`를 설정할 수 있습니다.\n```js\nmodule.exports = {\n  images: {\n    dangerouslyAllowSVG: true,\n    contentSecurityPolicy: \"default-src 'self'; script-src 'none'; sandbox;\",\n  },\n};\n```\n\n## Animated 이미지\n기본 [loader](https://beta.nextjs.org/docs/api-reference/components/image#loader)는 애니메이션 이미지에 대한 이미지 최적화를 자동으로 우회하고 이미지를 있는 그대로 제공합니다.\n애니메이션 파일에 대한 자동 감지는 최선의 노력이며 GIF, APNG, WebP를 지원합니다. 주어진 애니메이션 이미지에 대해 이미지 최적화를 명시적으로 우회하려면 [unoptimized prop](https://beta.nextjs.org/docs/api-reference/components/image#unoptimized)을 사용하세요.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
   "tags": ["nextjs","API","Reference","Image"],
   "thumbnail": "https://image.dnkdream.com/20221218_0834Su_earth-g5575d8b37_640.jpg",
   "createdAt": "2022-12-18 08:47:23.017",
   "updatedAt": "2022-12-18 08:47:23.017"
 },
 {
   "id": "ac239ed2-f1f8-4292-8a93-4db7f3a2338b",
   "category": "잡담",
   "title": "TS-4 썬더볼트 독",
   "body": "# TS-4 썬더볼트 독 도착!\n아기다리 고기다리던 썬더볼트4 독인 칼디짓의 TS-4 가 왔다... ㅜㅜ\n이 얼마나 기다렸던가...\n솔직히 TS-3 Plus도 잘 사용했었지만 약간씩의 불만이 있었는데 이번 TS-4는 나에게 딱 완벽하다 ㅋㅋ\n![](https://image.dnkdream.com/220709_193207_405345e0d45fd7413420da20d)\n\n## 구성품 살펴보기\n![](https://image.dnkdream.com/220709_193240_405345e0d45fd7413420da20e)\n구성품은 이전 작과 비슷하다, 아니 거의 똑같다고 해야 하나...?\n눈에 띄는 변경점은 데이터 케이블이 썬더볼트3에서 썬더볼트4로 바뀌었다는 거?\n계속해서 이전 작인 TS-3 Plus와 비교해보자\n\n# 구성품 비교 TS3 Plus vs TS4\n## 썬더볼트 케이블\n![](https://image.dnkdream.com/220709_193354_405345e0d45fd7413420da20f)\n사진에서 보이는 것과 같이 이번엔 썬더볼트4로 바뀌었다. 근데 케이블도 그렇고 본체도 그렇고 인쇄된 문자가 흐릿해졌다. 일부러 저렇게 한 건가....??\n\n## 크기 및 포트 비교\n![](https://image.dnkdream.com/220709_193536_405345e0d45fd7413420da210)\n![](https://image.dnkdream.com/220709_193558_405345e0d45fd7413420da211)\n![](https://image.dnkdream.com/220709_193630_405345e0d45fd7413420da212)\n![](https://image.dnkdream.com/220709_193640_405345e0d45fd7413420da213)\n보이는 것과 같이 좌측이 TS-4, 우측이 TS-3 Plus 이다.\n내부 성능 비교는 나중에 작성해야지... 지금은 급하게 차 안에서 작성해봤다.. ㅋㅋ",
   "tags": ["썬더볼트4","TS-4","칼디짓","Caldigit"],
   "thumbnail": "https://image.dnkdream.com/220709_193022_405345e0d45fd7413420da20c",
   "createdAt": "2022-07-09 01:37:17.495",
   "updatedAt": "2022-11-13 06:35:10.12"
 },
 {
   "id": "ad0fa281-83b1-4104-a2e4-da9faffc4c64",
   "category": "Remix",
   "title": "Remix.run Docs - Pages (Philosophy)",
   "body": "우리는 신용카드 회사, 소셜 미디어 플랫폼, 학습 관리 시스템, 컨텐츠 관리 시스템 및 전자 상거래를 위한 정적 사이트 등 다양한 유형의 웹 사이트에서 작업을 했습니다. 우리는 또한 교육 회사인 [React Training](https://reacttraining.com/)과 함께 수백 개의 개발 팀을 교육했습니다.\n\n이 팀은 우리 모두가 정기적으로 사용하는 웹 사이트를 구축합니다. 개인 개발 경험과 클라이언트 제품을 기반으로 웹 프로젝트의 프론트엔드, 백엔드 모두의 동적 특성을 처리할 수 있도록 `Remix`를 구축했습니다.\n\n리믹스의 철학은 네 가지로 요약할 수 있습니다.\n- 컨텐츠 / 데이터에서 소스 코드를 분리하는 것을 포함, 서버 / 클라이언트 모델을 수용합니다.\n- 브라우저, HTTP, HTML과 같은 웹 기반에 대항하는 것이 아니라 함께 작업합니다.\n- 자바스크립트를 사용해 브라우저의 동작을 에뮬레이션, 사용자 경험을 강화합니다.\n- 기본 기술을 과도하게 추상화하지 않습니다.\n\n# Server / Client Model\n서버를 빠르게 만들 수 있지만 사용자의 네트워크는 제어를 할 수 없습니다.\n\n오늘날의 웹 인프라를 사용하면 서버를 빠르게 만드는데 정적 파일은 필요하지 않습니다. 빠르게 만들 수 없는 것은 사용자의 네트워크입니다. 당신이 할 수 있는 유일한 일은 `네트워크를 통해 전송하는 물품의 양을 줄이는` 겁니다. 더 적은 Javascript, 더 적은 JSON, 더 적은 CSS. 이것은 코드를 이동할 수 있는 서버와 점진적인 개선을 선호하는 프레임워크가 있을 때 가장 쉽습니다.\n\nRemix가 네트워크를 통해 적은 양의 데이터를 보내는데 도움이 되는 많은 방법이 있으며 우리는 그들 모두에 대해 이야기하기를 희망하지만 지금은 레코드 목록을 가져오는 방법 중 하나를 예제로 보겠습니다.\n\n[Github Gist API](https://api.github.com/gists)를 고려해보죠.\n이 Payload는 압축을 풀면 75kb이고 네트워크를 통해 압축하면 12kb입니다. 브라우저에서 가져오면 사용자가 모두 다운로드하게 됩니다. 다음과 같이 보입니다.\n```jsx\nexport default function Gists() {\n  const gists = useSomeFetchWrapper(\n    \"https://api.github.com/gists\"\n  );\n  \n  if (!gists) {\n    return <Skeleton />;\n  }\n  \n  return (\n    <ul>\n      {gists.map((gist) => (\n        <li key={gist.id}>\n          <a href={gist.html_url}>\n            {gist.description}, {gist.owner.login}\n          </a>\n          <ul>\n            {Object.keys(gist.files).map((key) => (\n              <li key={key}>{key}</li>\n            ))}\n          </ul>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\nRemix를 사용하면 사용자에게 데이터를 보내기 전 서버에서 데이터를 필터링 할 수 있습니다.\n```jsx\nimport { json } from \"@remix-run/node\"; // or cloudflare/deno\n\nexport async function loader() {\n  const res = await fetch(\"https://api.github.com/gists\");\n  const gists = await res.json();\n\n  return json(\n    gists.map((gist) => ({\n      description: gist.description,\n      url: gist.html_url,\n      files: Object.keys(gist.files),\n      owner: gist.owner.login,\n    }))\n  );\n}\n\nexport default function Gists() {\n  const gists = useLoaderData<typeof loader>();\n\n  return (\n    <ul>\n      {gists.map((gist) => (\n        <li key={gist.id}>\n          <a href={gist.url}>\n            {gist.description}, {gist.owner}\n          </a>\n          <ul>\n            {gist.files.map((key) => (\n              <li key={key}>{key}</li>\n            ))}\n          </ul>\n        </li>\n      ))}\n    </ul>\n  );\n}\n```\n이렇게 하면 페이로드가 압축된 12kb, 총 75kb에서 압축된 1.8kb, 총 3.8kb로 용량이 줄어듭니다. 20배나 더 적습니다. 또한 페이지가 렌더링되기 전 Remix가 이 데이터를 fetch(또는 prefetch)하기 때문에 모든 skeleton UI를 제공할 필요가 없습니다.\n\n이는 Server / Client 모델을 채택해 사용자 네트워크를 통해 전송하는 횟수를 줄임으로써 앱 속도를 높이는데 도움이 되는 한 가지 예일 뿐입니다.\n\n# 웹 표준, HTTP 및 HTML\n이러한 기술들은 오랫동안 사용되어 왔고 상당히 견고합니다. Remix는 이들을 완전 포용합니다.\nHTTP 캐싱, assets를 위한 URL의 포커스, 동적 서버 렌더링 및 `<link rel=prefetch>`와 같은 HTML 기능을 결합하면 앱을 빠르게 만들 수 있습니다. 브라우저와 HTML은 20년 이상 지나면서 정말 좋아졌습니다.\n\nRemix API를 최소한으로 유지하고 대신 웹 표준으로 작업합니다.\n\n예를 들어 자체 req/res API를 만들거나 Node API를 사용하는 대신 Remix는 [Web Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 객체와 함께 작동합니다. Remix에 능숙해지면 [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request), [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response), [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) 및 [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL)과 같은 웹 표준에 능숙해지는 것입니다. 이러한 모든 항목들은 이미 브라우저에 있으며 이제 배포 위치에 관계없이 서버에 있습니다.\n\n데이터 뮤테이션을 수행할 때의 HTML 형식(`form`)을 보강했습니다. 다음 페이지를 위해 데이터와 assets들을 prefetch할 때 `<link rel=\"prefetch\">`를 사용하고 브라우저가 리소스 캐싱의 모든 복잡성을 처리하도록 합니다. 브라우저에 사용 사례에 대한 API가 있는 경우 Remix가 이를 사용합니다.\n\n# 점진적 향상\n대부분의 최신 프레임워크에는 데이터 읽어오기 API만 있지만 Remix는 읽기, 쓰기가 모두 있습니다. HTML `<form>`은 90년대부터 데이터 뮤테이션의 주요 요소였습니다. Remix는 해당 API를 수용하고 강화합니다. 이는 Remix 앱 데이터 계층이 페이지에서 자바스크립트를 사용하거나 사용하지 않고도 작동할 수 있습니다.\n\n자바스크립트를 추가하면 Remix가 페이지 전환 시 두 가지 방법으로 사용자 경험을 가속화할 수 있습니다.\n- Javascript 및 CSS assets 다운로드 및 평가하지 않음\n- 변경되는 레이아웃 부분에 대한 데이터만 fetch\n\n또한 페이지의 Javascript를 사용하여 Remix는 개발자에게 페이지 전환 시 UX를 더 좋게 만드는 API를 제공할 수 있습니다.\n- 브라우저의 스피닝 파비콘보다 더 멋진 pending UI를 추가합니다.\n- 데이터 작업(생성, 읽기, 업데이트, 삭제 등)에 낙관적인 UI 추가\n\n마지막으로 데이터 뮤테이션이 Remix에 내장되어 있기 때문에 뮤테이션 이후 변경되었을 수 있는 데이터를 다시 가져올 시기를 알고 페이지 내 다른 부분이 동기화하지 않도록 합니다.\n\n요점은 Javascript 없이 앱이 작동하도록 만드는 것이 아니라 더 단순한 Server / Client 모델을 유지하는 것입니다. 문 앞에 Javascript를 남겨놓을 수 있다는 것은 좋은 사이드 이펙트입니다.\n\n# 지나친 추상화 금지\nRemix의 역할은 스택의 중앙을 가로지르고 비켜주는 것입니다. 우리는 가능한 한 많은 *Remixisms* 을 피하고 대신 웹이 이미 가지고 있는 표준 API를 더 쉽게 사용할 수 있도록 합니다.\n\n우리는 Remix 이전 5년 동안 교육자였습니다. 우리의 슬로건은 `Build Better Websites` 입니다. 우리는 또한 때때로 Remix를 사용해 더 나은 웹사이트 구축 등 마지막에 약간의 추가 사항이 있다고 생각합니다. Remix를 잘하면 우연하게도 웹 개발 전반에 능숙해집니다.\n\nRemix API는 기본 브라우저 / HTTP / Javascript를 편리하게 사용할 수 있게 해주지만 이러한 기술은 사용자에게 숨겨지지 않습니다.\n\n예를 들어 앱의 특정 레이아웃에서 CSS를 가져오는 작업은 `links`라는 라우트 모듈 메소드를 사용하여 수행하며 여기서 HTML `<link>` 태그 값이 있는 객체 배열을 리턴합니다. 기본 기술을 숨기지 않고 앱의 성능을 최적화할 수 있을 정도로 추상화합니다.(객체이므로 중복 제거, preload 가능)\n\n`links`와 함께 Remix를 사용해 assets를 사전 로드하는 방법을 알아보고 모든 웹사이트에서 assets를 사전 로드하는 방법을 배웠습니다.\n\n> Remix를 잘하고 웹을 잘하세요!\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
   "tags": ["Remix","remix.run","Docs","Philosophy"],
   "thumbnail": "https://image.dnkdream.com/20221223_2211Fr_busts-g5fc2e8c25_640.jpg",
   "createdAt": "2022-12-23 22:11:19.971",
   "updatedAt": "2022-12-23 22:11:19.971"
 },
 {
   "id": "b8322317-b218-41e3-ae10-da97fe2f4330",
   "category": "Nextjs",
   "title": "Next.js 13 Conf",
   "body": "Next.js 13 컨퍼런스 내용을 정확치 않지만 이해가 될 정도로만 번역을 해보고자 합니다.\n정확한 내용은 아니고 개인이 참고하려는 글이니 혹시 누가 보더라도 양해해 주시기 바랍니다.\n\nNext.js 컨퍼런스에서 발표한 바와 같이 Next.js 13(Stable)은 제한없이 동적인 기반을 마련합니다.\n\n- app Directory (beta): 쉽고, 빠르고 작은 클라이언트 자바스크립트\n\t- Layouts\n    - React Server Components\n    - Streaming\n- Turbopack (alpha): 최대 700배 빠른 Rust 기반 Webpack 교체\n- 새로운 @next/image: 네이티브 브라우저 지연 로딩으로 더 빠릅니다\n- 새로운 @next/font (beta): 레이아웃 이동없이 자동 자체 호스팅 폰트\n- 개선된 next/link: 자동 &lt;a&gt; 태그로 간소화된 API\n\nNext.js 13 그리고 pages 디렉토리는 안정적이며 프로덕션 준비가 되었습니다. 다음을 실행하여 업데이트 하세요.\n```js\n$ npm i next@latest react@latest react-dom@latest eslint-config-next@latest\n```\n\n# 새로운 app 디렉토리 (beta)\n오늘 우리는 Next.js의 라우팅 및 레이아웃 경험을 개선하고 app 디렉토리의 도입과 함께 React의 미래에 맞춰 조정하고 있습니다. 이는 커뮤니티 피드백을 위해 이전에 게시되었던 [Layouts RFC](https://nextjs.org/blog/layouts-rfc)의 후속조치입니다.\napp 디렉토리는 현재 beta 버전이며 아직 프로덕션에서는 사용하지 않는게 좋습니다.\n개선된 next/image, next/link 컴포넌트와 같은 안정적인 기능이 작동하는 pages 디렉토리와 함께 Next.js 13을 사용하고 원하는 속도로 app 디렉토리를 선택할 수 있습니다.\npages 디렉토리는 당분간 계속 지원될 것입니다.\n\napp 디렉토리에는 다음에 대한 지원이 포함됩니다.\n- Layouts\n\t- 스테이트 유지, 비용이 많이 드는 리렌더링을 피하면서 라우트 간에 UI를 쉽게 공유합니다.\n- Server Components\n\t- 가장 다이나믹한 애플리케이션의 기본 서버 우선 설정\n- Streaming\n\t- 렌더링 되는 즉시 로드 상태 및 UI 단위 스트림 표시\n- Support for Data Fetching\n\t- async Server Components 및 확장된 fetch API는 컴포넌트 레벨 fetch를 지원합니다.\n![](https://s3.ap-northeast-2.amazonaws.com/image.dnkdream.com/20221117_0434Th_Untitled.png)\n\n## Layouts\napp 디렉토리를 사용하면 탐색 전체에서 스테이트를 유지하고 비용이 많이 드는 리렌더링을 방지하며 고급 라우팅 패턴을 활성화하는 복잡한 인터페이스를 쉽게 배치할 수 있습니다.\n더 나아가, 레이아웃을 중첩하고 컴포넌트, 테스트 및 스타일과 함께 애플리케이션 코드를 함께 배치할 수 있습니다.\n![](https://s3.ap-northeast-2.amazonaws.com/image.dnkdream.com/20221117_0435Th_Untitled%20%281%29.png)\n\napp 내부에 라우트를 생성하려면 page.js 라는 단일 파일이 필요합니다.\n```jsx\n// app/page.js\n// 이 파일은 index route(/)에 매칭됩니다.\nexport default function Page() {\n  return <h1>Hello, Next.js!</h1>\n}\n```\n그 다음 파일 시스템을 통해 레이아웃을 정의할 수 있습니다. 레이아웃은 여러 페이지 간에 UI를 공유합니다. 탐색 시 레이아웃은 스테이트와 인터렉티브 함을 유지하며 리렌더링 되지 않습니다.\n```jsx\n// app/blog/layout.js\nexport default function BlogLayout() {\n  return <section>{children}</section>\n}\n```\n[layouts 및 pages](https://beta.nextjs.org/docs/routing/fundamentals)에 대해 자세히 알아보거나 [예제를 배포하여 사용](https://vercel.com/templates/next.js/app-directory)해 보세요.\n\n## Server Components\napp/ 디렉토리는 React의 새로운 Server Components 아키텍처를 지원합니다. 서버 및 클라이언트 컴포넌트는 서버와 클라이언트를 각각 가장 잘 사용하므로 뛰어난 개발자 경험을 제공하는 단일 프로그램 모델로 빠르고, 고도로 상호 작용하는 앱을 구축할 수 있습니다.\nServer Components를 사용해 복잡한 인터페이스를 구축하는 동시에 <span style=\"color: red;\">클라이언트로 전송되는 자바스크립트의 양을 줄여 초기 페이지 로드 속도를 높일 수 있는 </span>토대를 마련하고 있습니다.\n라우트가 로드되면 캐시 가능하고 크기를 예측할 수 있는 Next.js 및 React 런타임이 로드됩니다. 이 런타임은 애플리케이션이 커져도 크기가 늘어나지 않습니다. 또한 런타임은 비동기식으로 로드되므로 HTML이 클라이언트에서 점진적으로 향상될 수 있습니다.\n\n[Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components)에 대해 자세히 알아보거나 [예제를 배포하여 사용](https://vercel.com/templates/next.js/app-directory)해 보세요.\n\n## Streaming\napp/ 디렉토리는 UI의 렌더링된 단위를 클라이언트에 점진적으로 렌더링하고 증분적으로 스트리밍하는 기능을 도입합니다.\nNext.js의 Server Components 및 중첩 layouts를 사용하면 특별히 데이터가 필요하지 않은 페이지 부분을 즉시 렌더링하고 데이터를 가져오는 페이지 부분에 대한 로드 상태를 표시할 수 있습니다.\n이 접근 방식을 사용하면 사용자는 상호 작용을 시작하기 전에 전체 페이지가 로드될 때까지 기다릴 필요가 없습니다.\n![](https://s3.ap-northeast-2.amazonaws.com/image.dnkdream.com/20221117_0443Th_Untitled%20%282%29.png)\nVercel에 배포될 때 app/ 디렉토리를 사용하는 Next.js 13 애플리케이션은 성능 향상을 위해 기본적으로 Node.js 및 Edge 런타임 모두에서 응답을 스트리밍합니다.\n\n[Streaming](https://beta.nextjs.org/docs/data-fetching/fundamentals)에 대해 자세히 알아보거나 [예제를 배포하여 사용](https://vercel.com/templates/next.js/app-directory)해 보세요.\n\n## Data Fetching\nReact의 최근 Promise 지원 RFC는 컴포넌트 내에서 데이터를 가져오고 Promise를 처리하는 강력하고 새로운 방법을 소개합니다.\n```jsx\n// app/page.js\nasync function getData() {\n  const res = await fetch('https://api.example.com/...');\n  // 리턴 값은 직렬화(serialized) 되지 않습니다.\n  // 날짜, 지도, 세트 등을 리턴할 수 있습니다.\n  return res.json();\n}\n\n// 이곳은 async Server Components 입니다.\nexport default async function Page() {\n  const data = await getData();\n  \n  return <main>{/* ... */}</main>;\n}\n```\n네이티브 fetch 웹 API도 React 및 Next.js에서 확장되었습니다.\n[fetch 요청을 자동으로 중복 제거하고 컴포넌트 레벨에서 데이터를 가져오고, 캐시하고, 재검증하는 하나의 유연한 방법](https://beta.nextjs.org/docs/data-fetching/fundamentals#automatic-fetch-request-deduping)을 제공합니다.\n이는 정적 사이트 생성(SSG), 서버 측 렌더링(SSR), 증분 정적 재생성(ISR)의 모든 이점을 하나의 API를 통해 사용할 수 있음을 의미합니다.\n```js\n// 이 요청은 수동으로 무효화될 때까지 캐시됩니다.\n// getStaticProps 와 비슷합니다.\n// force-cache 는 디폴트 값이며, 생략 가능합니다.\nfetch(URL, { cache: 'force-cache' });\n\n// 이 요청은 매 요청시 새로 가져옵니다.\n// getServerSideProps 와 비슷합니다.\nfetch(URL, { cache: 'no-store' });\n\n// 이 요청은 10초마다 캐시됩니다.\n// revalidate 옵션을 사용한 getStaticProps 와 비슷합니다.\nfetch(URL, { next: { revalidate: 10 } });\n```\napp 디렉토리에서 서버의 Streaming Response 지원을 포함하여 [layouts, pages](https://beta.nextjs.org/docs/routing/pages-and-layouts), components 내부의 데이터를 가져올 수 있습니다.\n로딩 및 오류 상태를 처리하고 UI가 렌더링될 때 스트리밍하는 인체공학적인 방법을 사용하고 있습니다. 향후 릴리스에서는 데이터 변형(Mutation)도 개선하고 단순화할 예정입니다.\n![](https://s3.ap-northeast-2.amazonaws.com/image.dnkdream.com/20221117_0451Th_Untitled%20%283%29.png)\n\nReact 및 Next.js의 새로운 시대를 구축하기 위해 오픈 소스 커뮤니티, 패키지 관리자 및 React 생태계에 기여하는 기타 회사와 협력하게 되어 기쁩니다.\n\n컴포넌트 내부에서 데이터 fetch를 함께 배치하고 클라이언트에 더 적은 자바스크립트를 제공하는 기능은 우리가 app/ 디렉토리에 포함하게 된 것을 기쁘게 생각하는 커뮤니티 피드백의 두 가지 중요한 부분이었습니다.\n\n[Data fetch](https://beta.nextjs.org/docs/data-fetching/fundamentals)에 대해 자세히 알아보거나 [예제를 배포하여 사용](https://vercel.com/templates/next.js/app-directory)해 보세요.\n\n### Turbopack 소개 (Alpha)\n\nNext.js 13에는 Webpack의 새로운 Rust 기반 후속제품인 [Turbopack](https://vercel.com/blog/turbopack)이 포함되어 있습니다.\n웹팩은 30억 회 이상 다운로드 되었습니다. 웹팩은 웹 구축의 필수적인 부분이었지만 자바스크립트 기반 도구로 가능한 최대 성능의 한계에 도달했습니다.\nNext.js 12에서 우리는 기본 Rust 기반 도구로의 전환을 시작했습니다. 우리는 Babel에서 마이그레이션하는 것으로 시작해 17배 더 빠른 트랜스파일을 얻었습니다. 그리고 Terser를 교체하여 축소가 6배 빨라졌습니다. 번들링을 위해 네이티브에 올인 할 때입니다.\nNext.js 13에서 Turbopack 알파를 사용하면 다음과 같은 결과가 나타납니다.\n- Webpack 보다 700배 빠른 업데이트\n- Vite 보다 10배 빠른 업데이트\n- Webpack 보다 4배 빠른 콜드 스타트\n![](https://s3.ap-northeast-2.amazonaws.com/image.dnkdream.com/20221117_0453Th_Untitled%20%284%29.png)\n\n[Turbopack](https://turbo.build/pack)은 개발에 필요한 최소한의 자산만 번들로 제공하므로 시작 시간이 매우 빠릅니다. 3,000개의 모듈이 있는 애플리케이션에서 <span style=\"color: red;\">Turbopack은 부팅하는데 1.8초</span>가 걸립니다. <span style=\"color: red;\">Vite는 11.4초, Webpack은 16.5초</span>가 걸립니다.\nTurbopack은 Server Components, Typescript, JSX, CSS 등을 즉시 지원합니다. 알파기간 동안 [많은 기능](https://turbo.build/pack/docs/features)이 아직 지원되지 않습니다. Turbopack을 사용하여 로컬 반복 속도를 높이는 것에 대한 피드백을 듣고 싶습니다.\n\n> 참고 : 현재 Next.js의 Turbopack은 next dev만 지원합니다. 또한 Turbopack을 통해 다음 빌드에 대한 지원을 추가하기 위해 노력하고 있습니다.\n> \nnext dev —turbo 를 사용해 Next.js 13에서 Turbopack 알파 버전을 사용해 보세요.\n\n## next/image\nNext.js 13은 강력한 새 이미지 컴포넌트를 도입하여 레이아웃 변경 없이 이미지를 쉽게 표시하고 성능 향상을 위해 필요에 따라 파일을 최적화할 수 있습니다.\nNext.js 커뮤니티 설문 조사에서 <span style=\"color: red;\">응답자의 70%</span>가 프로덕션 환경에서 Next.js 이미지 컴포넌트를 사용했으며 결과적으로  <span style=\"color: red;\">Core Web Vitals가 개선</span>되었다고 말하고 있습니다. Next.js 13에서는 next/image를 더욱 개선하고 있습니다.\n\n새로운 Image 컴포넌트\n- 더 적은 클라이언트 측 자바스크립트\n- 더 쉬운 스타일 지정 및 구성\n- 기본적으로 Alt 태그가 필요한 접근성 높음\n- 웹 플랫폼과 일치\n- 기본 지연 로딩에 hydration이 필요하지 않기 때문에 더 빠름\n\n```jsx\nimport Image from 'next/image';\nimport avatar from './lee.png';\n\nfunction Home() {\n  // 향상된 접근성을 위해 항상 alt를 사용해야 합니다.\n  // 선택사항: 이미지 파일은 app/ 디렉토리 내에 함께 배치 가능\n  return <Image alt=\"leeerob\" src={avatar} placeholder=\"blur\" />;\n}\n```\n[Image Component](https://nextjs.org/docs/basic-features/image-optimization)에 대해 자세히 알아보거나 [예제를 배포하여 사용](https://vercel.com/templates/next.js/nextjs-boilerplate)해 보세요.\n\n### Next.js 13에서 next/image 업그레이드\n이전 이미지 컴포넌트는 next/legacy/image로 이름이 변경되었습니다. next/image의 기존 사용을 next/legacy/image로 자동 업데이트하는 codemod를 제공합니다.\n예를 들어 이 명령은 루트에서 실행될 때 ./pages 디렉토리에서 codemod를 실행합니다.\n```js\n$ npx @next/codemod next-image-to-legacy-image ./pages\n```\n[codemod](https://nextjs.org/docs/advanced-features/codemods)에 대해 자세히 알아보거나 [문서를 확인](https://nextjs.org/docs/basic-features/image-optimization)해 보세요.\n\n## @next/font\nNext.js 13의 새로운 폰트 시스템을 소개합니다.\n- 사용자 지정 폰트를 포함해 폰트를 자동으로 최적화합니다.\n- 개인정보보호 및 성능 향상을 위해 외부 네트워크 요청을 제거합니다.\n- 모든 폰트 파일에 대한 자체 호스팅 내장\n- CSS 크기 조정 속성을 사용해 자동으로 제로 레이아웃 이동\n\n이 새로운 폰트 시스템을 사용하면 성능과 개인정보보호를 염두에 두고 모든 구글 폰트를 편리하게 사용할 수 있습니다. CSS 및 폰트 파일은 빌드 시 다운로드 되며 나머지 정적 자산과 함께 자체 호스팅됩니다. 브라우저에서 구글로 요청을 보내지 않습니다.\n```jsx\nimport { Inter } from '@next/font/google';\n\nconst inter = Inter();\n\n<html className={inter.className}>\n```\n\n자동 자체 호스팅, 캐싱 및 폰트 파일의 사전 로드에 대한 지원을 포함, 사용자 지정 폰트도 지원됩니다.\n```jsx\nimport localFont from '@next/font/local';\n\nconst myFont = localFont({ src: './my-font.woff2' });\n\n<html className={myFont.className}>\n```\n폰트 표시, 사전 로드, 대체 등을 포함해 뛰어난 성능과 레이아웃 변경 없이 폰트 로드 환경의 모든 부분을 사용자 지정할 수 있습니다.\n\n[새로운 폰트 컴포넌트](https://nextjs.org/docs/basic-features/font-optimization)에 대해 자세히 알아보거나 [예제를 배포해 사용](https://nextjs.org/blog/next-13)해 보세요.\n\n## next/link\nnext/link는 더 이상 수동으로 &lt;a&gt; 태그를 자식으로 추가할 필요가 없습니다.\n이것은 12.2에서 실험적 옵션으로 추가되었으며, 이제는 기본 값입니다. Next.js 13에서 &lt;Link&gt;는 항상 &lt;a&gt;를 렌더링하고 props를 기본 태그로 전달할 수 있도록 합니다.\n\n```jsx\nimport Link from 'next/link';\n\n// NExt.js 12: <a>는 중첩되어야 하며 그렇지 않으면 제외됨\n<Link href=\"/about\">\n\t<a>About</a>\n</Link>\n\n// Next.js 13: <Link> 태그는 항상 <a> 태그를 렌더링함\n<Link href=\"/about\">\n\tAbout\n</Link>\n```\n\n[개선된 next/link 컴포넌트](https://nextjs.org/docs/api-reference/next/link)에 대해 자세히 알아보거나 [예제를 배포해 사용](https://vercel.com/templates/next.js/nextjs-boilerplate)해 보세요.\n\n### Next.js 13에서 next/link 업그레이드\nlinks 를 Next.js 13으로 업그레이드하기 위해 코드베이스를 자동으로 업데이트하는 codemod를 제공합니다.\n예를 들어 이 명령은 루트에서 실행될 때 ./pages 디렉토리에서 codemod를 실행합니다.\n\n```jsx\n$ npx @next/codemod new-link ./pages\n```\n\n[codemod](https://nextjs.org/docs/advanced-features/codemods)에 대해 자세히 알아보거나 [문서를 확인](https://nextjs.org/docs/basic-features/image-optimization)해 보세요.\n\n## OG Image Generation\nOpen Graph 이미지라고도 하는 소셜 카드는 컨텐츠 클릭 참여율을 크게 높일 수 있으며 일부 실험에서는 최대 40% 더 나은 전환율을 보여줍니다. 정적 소셜 카드는 시간이 오래 걸리고 오류가 발생하기 쉬우며 유지관리가 어렵습니다. 이 때문에 소셜 카드가 종종 부족하거나 건너뛰기도 합니다.\n\n지금까지 즉석에서 개인화하고 계산해야 하는 동적 소셜 카드는 어렵고 비용이 많이 들었습니다. 동적 소셜 카드를 생성하기 위해 Next.js와 원활하게 자동하는 새로운 라이브러리 <span style=\"color: red;\">@vercel/og</span>를 만들었습니다.\n```jsx\n// pages/api/og.jsx\n\nimport { ImageResponse } from '@vercel/og';\n\nexport const config = {\n\truntime: 'experimental-edge',\n};\n\nexport default function () {\n\treturn new ImageResponse(\n\t\t(\n\t\t\t<div\n\t\t\t\tstyle={{\n\t\t\t\t\tdisplay: 'flex',\n\t\t\t\t\tfontSize: 128,\n\t\t\t\t\tbackground: 'white',\n\t\t\t\t\twidth: '100%',\n\t\t\t\t\theight: '100%',\n\t\t\t\t}}\n\t\t\t>\n\t\t\t\tHello, World!\n\t\t\t</div>\n\t\t),\n\t);\n}\n```\n이 접근 방식은 Vercel Edge Functions, WebAssembly, HTML 및 CSS를 이미지로 변환하고 React 컴포넌트 추상화를 활용하기 위한 새로운 핵심 라이브러리를 사용해 기존 솔루션보다 5배 더 빠릅니다.\n\n[OG Image Generation](https://vercel.com/docs/concepts/functions/edge-functions/og-image-generation)에 대해 자세히 알아보거나 [예제를 배포해 사용](https://vercel.com/new/clone?repository-url=https://github.com/vercel/examples/tree/main/edge-functions/vercel-og-nextjs&project-name=vercel-og-nextjs&repository-name=vercel-og-nextjs)해 보세요.\n\n## Middleware API Updates\nNext.js 12에서는 미들웨어를 도입해 Next.js 라우터의 완전한 유연성을 지원했습니다. 초기 API 디자인에 대한 피드백을 듣고 개발자 경험을 개선하고 강력한 새 기능을 추가하기 위해 몇 가지 사항을 추가했습니다.\n이제 요청에 헤더를 더 쉽게 설정할 수 있습니다.\n```jsx\n// middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\n\nexport function middleware(request: NextRequest) {\n  // 요청 헤더를 복제하고 새 헤더 'x-version'을 설정\n  const requestHeaders = new Headers(request.headers);\n  requestHeaders.set('x-version', '13');\n\n  // NextResponse.rewrite에서 요청 헤더를 설정할 수도 있음\n  const response = NextResponse.next({\n    request: {\n      // 새로운 요청 헤더\n      headers: requestHeaders,\n    },\n  });\n\n  // 새 응답 헤더 'x-version' 설정\n  response.headers.set('x-version', '13');\n  return response;\n}\n```\n\n이제 rewrite, redirect 없이 미들웨어에서 직접 응답을 제공할 수도 있습니다.\n```jsx\n// middleware.ts\nimport { NextRequest, NextResponse } from 'next/server';\nimport { isAuthenticated } from '@lib/auth';\n\n// /api/로 시작하는 라우트로 미들웨어를 제한\nexport const config = {\n  matcher: '/api/:function*',\n};\n\nexport function middleware(request: NextRequest) {\n  // 인증 기능을 호출하여 요청 확인\n  if (!isAuthenticated(request)) {\n    // 오류 메시지를 나타내는 JSON으로 응답\n    return NextResponse.json(\n      {\n        success: false,\n        message: 'Auth failed',\n      },\n      {\n        status: 401,\n      },\n    );\n  }\n}\n```\n미들웨어에서 응답을 보내려면 현재 next.config.js 내부에 experimental.allowMiddlewareResponseBody 구성 옵션이 필요합니다.\n\n## Breaking Changes\n- 최소 React 버전이 17.0.2에서 18.2.0으로 증가했습니다.\n- 12.x가 [수명 종료(PR)](https://github.com/vercel/next.js/pull/41482)에 도달했기 때문에 최소 Node.js 버전이 12.22.0에서 14.6.0으로 증가했습니다.\n- swcMinify 구성 속성이 false에서 true로 변경되었습니다. 자세한 내용은 [Next.js 컴파일러](https://nextjs.org/docs/advanced-features/compiler)를 참조하세요.\n- next/image import 이름이 next/legacy/image로, next/future/image의 이름이 next/image로 변경되었습니다. codemod를 사용해 import 이름을 안전하게 자동으로 바꿀 수 있습니다.\n- next/link의 자식은 더 이상 &lt;a&gt; 태그가 될 수 없습니다. 레거시 동작을 사용하려면 legacyBehavior 속성을 추가하고 업그레이드 하려면 &lt;a&gt; 태그를 제거하세요. codemod를 사용해 코드를 자동으로 업그레이드할 수 있습니다.\n- User-Agent가 봇일 때 라우트가 더 이상 미리 가져오지 않습니다.\n- 더 이상 사용되지 않는 next.config.js의 옵션이 제거되었습니다.\n- 지원되는 브라우저는 Internet Explorer를 삭제하고 최신 브라우저를 대상으로 변경되었습니다. 여전히 Browserslist를 사용해 대상 브라우저를 변경할 수 있습니다.\n    - 크롬 64+\n    - 엣지 79+\n    - 파이어폭스 67+\n    - 오페라 51+\n    - 사파리 12+\n\n자세한 내용은 [업그레이드 가이드](https://nextjs.org/docs/upgrading)를 확인하세요.",
   "tags": ["nextjs","13버전","넥스트"],
   "thumbnail": "https://image.dnkdream.com/20221117_0421Th_%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-11-17%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%201.21.08.png",
   "createdAt": "2022-11-17 05:03:07.708",
   "updatedAt": "2022-11-30 22:09:54.207"
 },
 {
   "id": "bcd4e8df-f076-43b2-965c-55d3b5165bd4",
   "category": "Travel",
   "title": "강화도 펜션 급 여행",
   "body": "# 급조된 여행\n나는 회사 특성 상 토요일, 일요일 업무를 하고 월요일이 고정 휴일인데, 일요일 일을 하던 중 갑자기 펜션이 가고 싶어졌다 ㅋㅋㅋ\n\n무슨 바람이 분 건지는 모르겠지만 평소 친한 직원들에게 같이 가자고 꼬시고 저녁에 급 출발을 했다.\n시간도 늦은 시간이었고 예정되어 있지 않던 여행이라 서울에서 갈 만한 곳은 사실 강화도 밖에 없다고 생각해서 찾아보고 결정을 했다.\n\n**여기어때**를 이용해서 예약을 했고 [석모도](https://namu.wiki/w/%EC%84%9D%EB%AA%A8%EB%8F%84)가 눈앞에 보이는 살짝 고지대의 펜션이었다.\n\n![](https://image.dnkdream.com/220615_063654_ba531520754442c329d386a01)\n\n# 이 죽일 놈의 날씨\n난 니콘 P1000 콤팩트 망원 카메라를 가지고 있어서 평소 달 촬영 등 이것 저것 마구 찍어댄다(기술은 전혀 없어서 항상 흔들린다 ㅜㅜ)\n하.지.만.... 여행 날 날씨는 썸네일 사진에서 보이듯이 해무가 잔뜩 끼고 구름도 가득하여 별도... 달도... 바닷가 조차도 전혀 제대로 찍히질 않아서 너무 안타까웠다...\n\n![](https://image.dnkdream.com/220615_063935_ba531520754442c329d386a02)\n\n날씨가 좋을 때는 달을 대충 찍어도 이 정도 사진을 뽑아주는 카메라인데...\n해무가 잔뜩 끼니 도착하자마자 찍은 사진이 이렇다...\n![](https://image.dnkdream.com/220615_064058_ba531520754442c329d386a03)\n\n아오... 눈으로는 정말 아름다웠는데...\n![](https://image.dnkdream.com/220615_064200_ba531520754442c329d386a04)\n![](https://image.dnkdream.com/220615_064214_ba531520754442c329d386a05)\n\n저 멀리 보이는 배도 당겨서 찍어보고\n![](https://image.dnkdream.com/220615_064229_ba531520754442c329d386a06)\n전선 위 새 한 마리가 찍어달라고 신호를 보내기에 찍어 주었다. ㅋㅋㅋㅋ\n\n# 눈 앞에 보이는 석모도\n아침이 되어 그나마 구름은 어느 정도 걷혔으나 해무는 여전히 끼어 있어 아쉬웠지만 줌을 당겨보았다.\n![](https://image.dnkdream.com/220615_064243_ba531520754442c329d386a07)\n드문드문 민가가 보인다. 섬 크기가 앞에서 보는 것과 달리 지도로 보니 꽤 크던데 정면에서 보니 작은 섬처럼 보인다.\n![](https://image.dnkdream.com/220615_064259_ba531520754442c329d386a08)\n\n# 준비된 여행을 하자\n다음 부터는 좀 더 채비를 갖추고 여행을 떠나야겠다.\n촬영도 제대로 하지 못하고 즐길 수 있는 시간이 거의 없는 상태로 떠나니 별 것 해보지도 못하고 피로만 가득 쌓여서 돌아오게 됐다.\n\n끝으로 강화도 끝자락에서 바라본 석모도 영상이다.\n수전증으로 인해 많이 흔들리지만 ㅋㅋ\n\n<iframe class=\"ql-video\" frameborder=\"0\" allowfullscreen=\"true\" src=\"https://www.youtube.com/embed/GEMG_JtdI4k?showinfo=0\"></iframe>\n\n> 그래도 너무 멋졌다!!",
   "tags": ["펜션","강화도","석모도 앞","급조 여행"],
   "thumbnail": "https://image.dnkdream.com/220615_063229_ba531520754442c329d386a00",
   "createdAt": "2022-06-14 12:46:10.261",
   "updatedAt": "2022-11-13 06:34:01.524"
 },
 {
   "id": "c332687d-30f6-468b-a647-8ba3912c95af",
   "category": "Nextjs",
   "title": "Next.js에 Naver map 얹기",
   "body": "개발자는 아니지만 친한 동생이 백엔드 서버 개발자인데 뜬금 프로젝트 하나 해보자고 해서 진행을 하게 되었는데 Next.JS에 네이버 맵을 띄워야 하는 상황이 오게 되어 이리저리 삽질(?) 하다가 확인된 내용들을 정리하고자 합니다..\n\n벨로그와 구글링을 통해 Next.js에 네이버 맵을 얹으려고 정보를 찾아보면 거의 대부분이 이전 버전의 naver map npm 모듈 을 사용한 글이거나 원인은 잘 모르겠으나 그대로 따라해도 작동을 하지 않아 이것 저것 찾아보며 결국 띄우긴 하여 기록을 합니다.\n\n```js\n$ npx create-next-app next-naver-map --typescript\n```\n\n\n# Naver Map API 등록\n프로젝트 생성 후 네이버 클라우드 플랫폼에 가입 후 네이버 맵 API 사용을 신청합니다.\n네이버 클라우드 플랫폼에 접속하여 로그인 후 우측 상단의 콘솔 메뉴를 클릭합니다.\n메뉴 중 Services ➡️ AI∙NAVER API\n\n![Image01](https://image.dnkdream.com/220613_224508_65feb512cdf867cae0ada4100)\n![Image02](https://image.dnkdream.com/220613_224520_65feb512cdf867cae0ada4101)\n![Image03](https://image.dnkdream.com/220613_224525_65feb512cdf867cae0ada4102)\n\n**Application** 등록 메뉴를 눌러 새 앱을 생성합니다.\n\n이후 아래와 같이 설정 후 **+추가** 를 해준 후 등록합니다.\n\n![Image04](https://image.dnkdream.com/220613_224544_65feb512cdf867cae0ada4103)\n\n그럼 이와 같이 앱이 등록되는데 저기서 인증정보를 눌러 Client ID키 값을 복사해 둡니다.\n![Image05](https://image.dnkdream.com/220613_224555_65feb512cdf867cae0ada4104)\n\n# Next.js에 네이버 맵 등록\nNext.js 프로젝트 경로에 .env.local 파일을 생성하고 아래와 같이 저장합니다.\n```js\nNEXT_PUBLIC_MAP_KEY=조금 전 Client ID 키\n```\nNext.js에서 .env.local 설정을 읽어올 때는 NEXT_PUBLIC_을 반드시 앞에 붙여주어야 합니다.\nCRA로 프로젝트를 만들었으면 */public/index.html* 내부에 네이버 스크립트를 작성하겠지만 Next.js 는 *_app.tsx* 내부에 next/script 모듈을 사용하여 작성해 줍니다.\n```jsx\nimport type { AppProps } from 'next/app';\nimport Head from 'next/head';\nimport Script from 'next/script';\n\nfunction App({ Component, pageProps ): AppProps) {\n  return (\n    <Head>\n      <meta charSet=\"utf-8\" />\n      <title>Next Naver Map</title>\n    </Head>\n    <Script\n      strategy=\"beforeInteractive\"\n      src={`https://openapi.map.naver.com/openapi/v3/maps.js?ncpClientId=${process.env.NEXT_PUBLIC_MAP_KEY}`}\n    />\n    <Component {...pageProps} />\n  );\n};\n\nexport default App;\n```\n\n그리고 저는 타입스크립트를 사용하였기에 *@types/navermaps* 모듈을 설치합니다.\nstyled-components 로 스타일을 할 거라 아래와 같이 설치합니다.\n\n```js\n$ npm i styled-components\n$ npm i -D @types/styled-components babel-plugin-styled-components @types/navermaps\n```\n\n*_document.tsx*\n```jsx\nimport type { DocumentContext, DocumentInitialProps } from 'next/document';\nimport Document, { Html, Head, Main, NextScript } from 'next/document';\nimport { Fragment } from 'react';\nimport { ServerStyleSheet } from 'styled-components';\n\nclass MyDocument extends Document {\n  static async getInitialProps(ctx: DocumentContext): Promise<DocumentInitialProps> {\n    const sheet = new ServerStyleSheet();\n\tconst originalRenderPage = ctx.renderPage;\n\n\ttry {\n\t\tctx.renderPage = () =>\n\t\t\toriginalRenderPage({\n\t\t\t\tenhanceApp: (App) => (props) =>\n\t\t\t\t\tsheet.collectStyles(<App {...props} />),\n\t\t\t});\n\t\tconst initialProps = await Document.getInitialProps(ctx);\n\n\t\treturn {\n\t\t\t...initialProps,\n\t\t\tstyles: [\n\t\t\t\t<Fragment key={new Date().toString()}>\n\t\t\t\t\t{initialProps.styles}\n\t\t\t\t\t{sheet.getStyleElement()}\n\t\t\t\t</Fragment>,\n\t\t\t],\n\t\t};\n\t} finally {\n\t\tsheet.seal();\n\t}\n\t\n\trender() {\n\t\treturn (\n\t\t\t<Html>\n\t\t\t\t<Head />\n\t\t\t\t<body>\n\t\t\t\t\t<Main />\n\t\t\t\t\t<NextScript />\n\t\t\t\t</body>\n\t\t\t</Html>\n\t\t);\n\t}\n}\n\nexport default MyDocument;\n```\n\n*.babelrc*\n```js\n{\n  \"presets\": [\"next/babel\"],\n  \"plugins\": [\n    [\n      \"styled-components\", {\n        \"ssr\": true,\n        \"displayName\": true,\n        \"preprocess\": false\n      }\n    ]\n  ]\n}\n```\n\n그럼 아래 코드와 같이 네이버 맵을 불러올 수 있습니다.\ndiv 태그에 꼭 id 값을 map 으로 하고 너비와 높이를 지정해 주면 됩니다.\n\n*pages/index.tsx*\n```jsx\nimport type { NextPage } from 'next';\n\nconst IndexPage: NextPage = () => {\n  return (\n    <div id=\"map\"></div>\n   );\n};\n\nexport default IndexPage;\n```\n\n위와 같이 작성하고 나면 텅~빈 화면이 나올 겁니다.\n맵의 크기 및 위치를 지정해 주어야 하죠.\n\n# 지도 위치 초기화\nNavigator의 Geolocation API를 이용하여 현재 위치를 확인하며 위치 정보 동의를 못 구할 시 임의 좌표를 입력합니다.\n그리고 myLocation이 'string'이 아니라면 즉, 좌표값이 들어있다면 그 위치를 센터로 네이버 맵을 생성합니다.\n\n*useMap.ts*\n```jsx\nimport { useEffect, useRef, useState } from 'react';\n\nfunction useMap() {\n  const mapRef = useRef<HTMLElement | null | any>(null);\n  const [myLocation, setMyLocation] = useState<\n    { latitude: number; longitude: number } | string\n  >('');\n\n  useEffect(() => {\n    // geolocation 이용 현재 위치 확인, 위치 미동의 시 기본 위치로 지정\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition((position) => {\n        setMyLocation({\n          latitude: position.coords.latitude,\n          longitude: position.coords.longitude,\n        });\n      });\n    } else {\n      window.alert('현재 위치를 알 수 없어 기본 위치로 지정합니다.');\n      setMyLocation({ latitude: 37.4862618, longitude: 127.1222903 });\n    }\n  }, []);\n\n  useEffect(() => {\n    if (typeof myLocation !== 'string') {\n      // 현재 위치 추적\n      let currentPosition = [myLocation.latitude, myLocation.longitude];\n      // Naver Map 생성\n      mapRef.current = new naver.maps.Map('map', {\n        center: new naver.maps.LatLng(currentPosition[0], currentPosition[1]),\n        zoomControl: true,\n      });\n    }\n  }, [myLocation]);\n\n  return {\n    myLocation,\n  };\n}\n\nexport default useMap;\n```\n\n*pages/index.tsx*\n```jsx\nimport type { NextPage } from 'next';\nimport styled from 'styled-components';\nimport useMap from '../hooks/useMap';\n\nconst IndexPage: NextPage = () => {\n  useMap();\n\n  return <MapBox id=\"map\"></MapBox>;\n};\n\n// Styles\nconst MapBox = styled.div`\n  width: 800px;\n  height: 800px;\n`;\n\nexport default IndexPage;\n\n```\n\n이렇게 작성하면 쨔란!\n![Image06](https://image.dnkdream.com/220613_230002_65feb512cdf867cae0ada4105)\n이렇게 지도가 나옵니다.\n나중에 시간이 가용하면 마커 작성 및 위치 추적 등 부가 기능도 기록해야겠네요.",
   "tags": ["Map","NAVER MAP","Naver","next","nextjs"],
   "thumbnail": "https://image.dnkdream.com/220610_151237_2c34ceef490f44e429bf76c00",
   "createdAt": "2022-06-09 21:19:19.186",
   "updatedAt": "2022-11-13 06:33:47.007"
 },
 {
   "id": "d5ade5a7-ba06-472c-a43c-20e8fdfb51e8",
   "category": "Remix",
   "title": "Remix 리액트 프레임워크",
   "body": "Remix 는 사용자 인터페이스에 집중하고 웹 표준을 지키며 빠르고 매끄럽고 탄력적인 사용자 경험**UI**를 제공할 수 있는 풀 스택 웹 프레임워크입니다.\n\n> 참고 : [fustbit Samuel Torimiro 님 글](https://fusebit.io/blog/remix-react-framework/?utm_source=www.google.com&amp;utm_medium=referral&amp;utm_campaign=none)\n\n리액트 내지는 기타 자바스크립트 라이브러리 및 프레임워크를 사용하면 **CSR(클라이언트 사이드 렌더링)** 웹을 빌드할 수 있습니다.\n이는 사용자가 웹을 처음 방문하면 자바스크립트가 필수 기능들을 처리할 때까지 빈 페이지가 표시됨을 의미합니다. 이로 인해 사용자 경험(UX)이 저하될 수 있으며 또한 클라이언트에서 HTML을 처리하여 검색엔진최적화(SEO)가 원활히 이루어지지 않습니다.\n리믹스는 *서버에서 HTML을 렌더링 한 후* 브라우저에 보내주기 때문에 뛰어난 SEO 성능을 보여줍니다. 또한 리믹스는 Mutation, Data fetching 등을 위한 Form 을 처리하는데 편리한 기능들을 제공합니다.\n\n# 다른 리액트 프레임워크\n다른 리액트 프레임워크들은 성능이 좋은 리액트 앱을 빌드하는데 충분히 도움이 됩니다. 가장 인기있는 프레임워크 중 하나는 Next.js를 꼽을 수 있습니다. 하지만 리믹스는 이에 비해 배울 가치가 있는 몇 가지 고유한 기능을 제공합니다.\n다음은 라우팅을 처리하는 방법에 따라 리믹스와 다른 프레임워크를 비교한 것입니다.\n\n## 라우팅\n웹 사이트는 일반적으로 정적(Static) 또는 동적(Dynamic) 컨텐츠를 렌더링하는 여러 페이지로 구성되기 때문에 라우팅 또는 웹사이트의 다른 페이지를 탐색하는 프로세스는 매우 중요한 기능입니다. 리믹스와 넥스트 모두 파일 기반 라우팅을 지원하며, 파일을 생성하면 브라우저를 통해 즉시 액세스할 수 있습니다.\n예를 들어 리믹스에서 새 프로젝트를 만들 때 route 폴더 안에 새 파일을 만들 수 있습니다. 두 프레임워크는 CSR(클라이언트 사이드 렌더링) 또한 탐색(새로고침 없는 이동)과 동적 라우팅을 지원합니다.\n리믹스에서는 파일 이름 앞에 $ 기호로 명명된 매개변수를 추가하여 이를 수행합니다.\n리믹스는 눈에 띄는 곳은 중첩 라우팅을 사용합니다. 넥스트는 파일 관점에서 중첩 라우팅을 지원하지만 리믹스는 각 라우팅의 하위 파일이 표시되어야 하는 위치를 결정할 수 있는 별도의 파일인 라우트의 계층을 생성할 수 있습니다.\n즉, 판 페이지 내에서 여러 라우팅을 활성화 할 수 있습니다.\n\n> 참고 : 리믹스의 라우트는 컴포넌트를 export 하는 파일을 의미합니다.\n\n*예제 : posts.jsx*\n```jsx\nimport { Outlet } from '@remix-run/react';\n\nexport default function Posts() {\n  return (\n    <div>\n      <h1>포스트 목록 라우트입니다.</h1>\n      <Outlet />\n    </div>\n  );\n}\n```\n\n이후 posts 라는 폴더를 생성하면 그 폴더의 각 파일들은 상위 라우트인 posts.jsx 파일에 명시된 Outlet 내부에 중첩(nested)될 수 있습니다.\nnew.jsx 라는 파일을 이 폴더 안에 생성한다고 가정해 보겠습니다.\n/posts/new 라우트로 이동하면 상위 라우트에 있는 컨텐츠가 new.jsx 라우트 컨텐츠로 대체됩니다.\n\n## SSG &amp; SSR\nSSG(정적 사이트 생성기)는 빌드 시 코드를 실행하고 CDN(컨텐츠 전송 네트워크)으로 배송하여 사용자에게 웹 사이트를 더 빠르게 전달 할 수 있습니다. 하지만 SSG 방식은 동적인 컨텐츠에서는 문제가 될 수 있습니다. 또한 정적 파일과 자산(assets)이 많은 경우 변경될 때마다 사이트를 다시 빌드하는데 시간이 많이 걸릴 수 있습니다.\nCloudflare Workers, Deno Deploy, AWS Lambda와 같은 서비스를 사용해 웹을 배포하는 경우 데이터가 사용자와 가깝기 때문에 SSG가 덜 중요하게 됩니다.\n리믹스는 서버에 데이터를 로드하고, 전체 HTML 파일을 생성해 브라우저로 다시 보내는 SSR(서버 사이드 렌더링)에 중점을 둡니다.\n넥스트는 여전히 SSG로 정적 페이지를 구성하고 SSR 로 동적 컨텐츠 구축하는 것을 권장합니다. 이것은 정적 사이트 생성 프레임워크인 Gatsby와 유사합니다.\n하지만 브라우저에서 리믹스를 실행할 수 있고 최신 데이터를 가질 수 있으므로 리믹스와 함께 SSG를 사용할 필요는 없습니다.\n\n## Data Fetching\n웹 사이트를 동적으로 만들려면 내부적으로 생성되었거나 타사 제공업체에서 얻은 API 또는 데이터베이스에서 데이터를 가져옵니다. 리믹스는 이 프로세스를 단순화 합니다.\n리믹스는 서버에서 코드를 실행하기 때문에 데이터도 서버에서 가져옵니다. 이것은 loader 라는 특정 함수를 사용하여 정의됩니다. 데이터는 서버에서 가져오기 때문에 브라우저로 다시 보내는 내용을 조작할 수 있게 됩니다.\n모든 데이터를 보낼 필요가 없으므로 원하는 방식으로 수정하고 필요한 만큼만 클라이언트에 다시 보낼 수 있습니다. 이에 따라 전송되는 총 데이터 양이 줄어들기 때문에 사용자 경험(UX)가 향상됩니다.\n\n*예제: posts.tsx*\n```jsx\nimport { json } from '@remix-run/{runtime}';\nimport { useLoaderData } from '@remix-run/react';\n\nexport const loader = async () => {\n  return json([\n    { id: \"1\", title: \"첫번째 제목\" },\n    { id: \"2\", title: \"두번째 제목\" },\n  ]);\n};\n\n﻿export default function Posts() {\n  const posts = useLoaderData();\n  \n  return (\n    <div>\n      <h1>포스트 목록</h1>\n      {posts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  );\n};\n```\n\n위 코드에서 loader 함수는 데이터를 가져오고 useLoaderData 훅으로 서버에서 실행되는 컴포넌트의 데이터에 액세스 합니다.\n\n> 라우트의 기본 함수는 항상 컴포넌트입니다\n\n대조적으로 넥스트는 getStaticProps 또는 getServerSideProps 등을 사용하여 컴포넌트에 데이터를 로드하는 방법을 제공합니다.\n\n## Form 핸들링\n웹을 만들 때 데이터를 변경(mutate)하는 방법이 필요합니다.\n리믹스는 브라우저가 양식을 처리하는 방법을 이해하기 때문에 이를 간단히 만들 수 있습니다.\n다른 리액트 프레임워크와 달리 리믹스는 기본 브라우저 기능을 따르므로 폼을 제출 할 때 자바스크립트가 필요하지 않습니다. 다만 폼 제출을 향상시키기 위해서 자바스크립트를 사용합니다.\n\n리믹스 폼 예제 \n```jsx\nimport { Form } from '@remix-run/react';\n\n...\n  return (\n    <Form method=\"post\">\n      <input type=\"text\" name=\"title\" />\n      <input type=\"text\" name=\"body\" />\n      <button type=\"submit\">생성</button>\n    </Form>\n  );\n...\n```\n  \n리믹스에서는 HTML에서 네이티브 &lt;form&gt; 엘리먼트가 수행하는 작업을 하는 &lt;Form&gt; 태그가 있으며 일부 자바스크립트 개선사항이 포함되어 있습니다. 또한 리믹스는 동일한 파일에서 작업 기능을 제공합니다. 서버에서 실행되는 요청(request)를 받고 폼 데이터를 처리하는 역할을 합니다.\n \n```jsx\nimport { redirect } from '@remix-run/{runtime}';\n\nexport async function action ({ request }) {\n  const body = await request.formData();\n  const post = await createPost(body);\n\n  return redirect('/posts');\n};\n```\n\n위 코드에서 Fetch API의 기본 요청 개체(request object)는 브라우저에서 제출된 폼 데이터를 가져옵니다. 폼 데이터를 얻으면 원하는 모든 작업을 수행할 수 있습니다. 이 코드는 createPost 라는 함수를 보여주고 리믹스에서 제공하는 리디렉션을 사용하여 사용자를 다른 페이지로 리디렉션 합니다.\n넥스트에서 자바스크립트로 폼 제출 기능을 향상시키려면 event.preventDefault() 함수를 사용한 후 자바스크립트를 사용해 폼 데이터를 제출하기 위한 POST request 를 보내야 합니다.\n리믹스는 이러한 추가 단계를 아끼므로 submit 버튼을 사용해 폼을 제출할 수 있습니다. 이에 따라 리믹스의 폼은 자바스크립트를 활성화하지 않고도 작동할 수 있습니다.\n\n## 쿠키 &amp; 세션 지원\n쿠키와 세션 등의 도움이 없이는 웹을 이용하는 특정 사용자를 추적하는 것이 불가능할 수 있습니다. 예를 들어 인증 기능이 있는 경우 사용자가 로그인에 성공하면 서버에서 브라우저로 쿠키를 보낼 수 있습니다.\n리믹스는 createCookie, isCookie, createCookieSessionStorage, isSession과 같은 여러 API를 사용하여 쿠키 및 세션 관리를 지원합니다. 하지만 넥스트를 이용할 경우 이를 관리하기 위해 초보자 같은 서드파티 라이브러리 등을 이용해야 합니다.\n\n## 에러, 인터럽트 등 처리\n리믹스의 각 라우트에는 ErrorBoundary 라는 에러 함수가 있을 수 있습니다. 이에 따라 자식 컴포넌트가 에러를 렌더링하면 앱이 충돌하지 않습니다. 에러는 부모 컴포넌트가 예상대로 작동하는 동안에만 자식 컴포넌트에 대해 표시가 됩니다. 이는 중첩 라우트(nested routes)로 인해 각 파일이 다른 파일과 독립적이기 때문입니다.\n넥스트에서 특정 라우트의 서버 에러가 생길 시 500 에러 발생으로 전체 UI가 작동하지 않게 됩니다.\n\n다음은 리믹스 ErrorBoundary 함수의 예입니다.\n```jsx\nexport function ErrorBoundary({ error }) {\n  return (\n    <div>\n      <p>{error}</p>\n    </div>\n  );\n};\n```\n라우트 모듈에 ErrorBoundary 함수가 없으면 다음 ErrorBoundary를 찾기 위해 상위로 버블됩니다.\n\n이는 에러가 상황에 따라 달라질 수 있음을 의미합니다.\n리믹스는 클라이언트에서 에러만 찾을 수 있는 리액트와 달리 클라이언트, 서버 모두에서 에러를 잡아낼 수 있습니다. 또한 한 번에 여러 POST 요청을 하려고 할 때 경쟁 조건(race condition)이 발생할 수 있습니다. 기본적으로 리믹스가 이를 처리하므로 오래된 데이터에 대한 걱정을 할 필요가 없습니다.\n\n> 다음으로 가벼운 농담을 랜덤으로 보여주는 웹을 만들며 리믹스를 연습해 보겠습니다",
   "tags": ["Remix","React","Framework"],
   "thumbnail": "https://image.dnkdream.com/220916_124608_d4bfb027666bdd7f358395f00",
   "createdAt": "2022-09-15 18:46:12.228",
   "updatedAt": "2022-11-17 20:50:33.055"
 },
 {
   "id": "ecb663e8-92e0-4365-abe6-a5388fcb8498",
   "category": "Nextjs",
   "title": "Next.js 13 API Reference - Link",
   "body": "`<Link>` 컴포넌트는 HTML `<a>` 엘리먼트를 확장하여 각 라우터간 [prefetch](https://beta.nextjs.org/docs/routing/linking-and-navigating#prefetching) 및 클라이언트 사이드 탐색을 제공하는 리액트 컴포넌트입니다.\n*Next.js*에서 각 라우터 사이를 탐색하는 기본 방법입니다.\n\n*app/page.tsx*\n```tsx\nimport Link from 'next/link';\n\nexport default function Page() {\n  return <Link href=\"/dashboard\">Dashboard</Link>\n}\n```\n\n# Props\n아래 표는 `<Link>` 컴포넌트에 사용할 수 있는 Props 요약입니다.\n| Prop | Example | Type | Required |\n| --- | --- | --- | --- |\n| [href](https://beta.nextjs.org/docs/api-reference/components/link#href) | `href=\"/dashboard\"` | String or Object | Yes |\n| [replace](https://beta.nextjs.org/docs/api-reference/components/link#replace) | `replace={false}` | Boolean | - |\n| [prefetch](https://beta.nextjs.org/docs/api-reference/components/link#prefetch) | `prefetch={false}` | Boolean | - |\n\n> 알아두면 좋은 점: `<a>` 태그 속성은 `<Link>`에 *Props*로 추가할 수 있습니다. 예: **className** 또는 **target=\"_blank\"** 는 렌더링 시 기본 `<a>` 태그로 전달됩니다.\n\n## href\n탐색할 경로 또는 URL 입니다. 이 값은 상대 경로입니다. 절대경로(예: *acme.com*)는 일반 `<a>` 태그를 대신 사용해야 합니다.\n**href**는 아래와 같이 객체도 허용합니다.\n```tsx\n// /about?name=test 로 이동\n<Link\n  href={{\n    pathname: '/about',\n    query: { name: 'test' },\n  }}\n>\n  About\n</Link>\n```\n\n## replace\n기본 값은 **false** 입니다. **true**일 경우 `next/link`는 [브라우저 히스토리](https://developer.mozilla.org/en-US/docs/Web/API/History_API) 스택에 새 URL을 추가하는 대신 현재 히스토리 상태를 대체합니다.\n\n*app/page.tsx*\n```tsx\nimport Link from 'next/link';\n\nexport default function Page() {\n  return <Link href=\"/dashboard\" replace>Dashboard</Link>\n}\n```\n\n## prefetch\n기본 값은 **true** 입니다. **true**인 경우 `next/link`는 백그라운드에서 페이지를 `prefetch` 합니다. 이는 클라이언트 사이드 탐색 성능을 향상시키는데 유용합니다. *Viewport\\(초기 또는 스크롤을 통해\\)*의 모든 `<Link />`가 미리 로드됩니다.\n`prefetch={false}`를 전달해 `prefetch`를 비활성화할 수 있습니다. `prefetch`가 비활성화 상태일 경우 **마우스 오버\\(hover\\)**시 `prefetch`가 계속 발생합니다. `prefetch`는 오직 프로덕션 모드에서만 사용 가능합니다.\n\n*app/page.tsx*\n```tsx\nimport Link from 'next/link';\n\nexport default function Page() {\n  return <Link href=\"/dashboard\" prefetch={false}>Dashboard</Link>\n}\n```\n\n# Legacy Props\n- `as`\n\t- `app` 디렉토리에서 URL을 마스킹하는 개념은 [고급 라우팅 패턴](https://beta.nextjs.org/docs/routing/fundamentals#advanced-routing-patterns)으로 처리됩니다. `pages` 디렉토리의 이전 동적 라우팅과의 호환성을 위해 `<Link>` 컴포넌트에 **props**로 전달할 수 있습니다. 하지만 이제 동적 세그먼트를 `href props`에 전달할 수 있으므로 `app` 디렉토리에서 `as`를 사용하는 것은 권장되지 않아요.\n- `legacyBehavior`\n\t- `<a>` 엘리먼트는 더 이상 `<Link>` 컴포넌트의 자식으로 필요하지 않습니다. 레거시 동작을 계속해서 사용하려면 `lecacyBehavior Props`를 추가하고 업그레이드 하려면 `<a>` 태그를 제거하세요. **codemod**를 사용해 코드를 자동 업그레이드 할 수 있습니다.\n- `passHref`: `<Link>`는 올바른 *href*로 `<a>` 엘리먼트를 렌더링하므로 필요하지 않습니다. 여기에는 다음과 같은 경우가 포함됩니다.\n\t- *\\<Link href=\"/about\"\\>About\\</Link>*\n    - *\\<Link href=\"/about\"\\>\\<CustomComponent /\\>\\</Link>*\n    - *\\<Link href=\"/about\"\\>\\<strong\\>About\\</strong\\>\\</Link>*",
   "tags": ["nextjs","API","Reference","Link"],
   "thumbnail": "https://image.dnkdream.com/20221217_2213Sa_chain-ge45a2baca_640.jpg",
   "createdAt": "2022-12-17 22:43:07.985",
   "updatedAt": "2022-12-17 22:43:07.985"
 }
]